#+TITLE: Repository of all of
#+STARTUP: showeverything
#+OPTIONS: toc:4
#+auto_tangle: t
#+AUTHOR: Prutserdt

#+BEGIN_SRC
 __  __                       _       _
|  \/  |_   _   ___  ___ _ __(_)_ __ | |_ ___
| |\/| | | | | / __|/ __| '__| | '_ \| __/ __|
| |  | | |_| | \__ \ (__| |  | | |_) | |_\__ \
|_|  |_|\__, | |___/\___|_|  |_| .__/ \__|___/
        |___/                  |_|
#+END_SRC

* Table of contents :toc:
- [[#about-this-document][About this document]]
- [[#my-dmenu-scripts][My dmenu scripts]]
  - [[#clipboard_dmsh][clipboard_dm.sh]]
  - [[#dmenuappssh][dmenuapps.sh]]
  - [[#dmenubackupsh][dmenubackup.sh]]
  - [[#dmenuemacssh][dmenuemacs.sh]]
  - [[#dmenuinternetsh][dmenuinternet.sh]]
  - [[#dmenukillsh][dmenukill.sh]]
  - [[#dmenupatchsh][dmenupatch.sh]]
  - [[#dmenustablesh][dmenustable.sh]]
  - [[#dmenuthunarsh][dmenuthunar.sh]]
  - [[#dmenuunicodesh][dmenuunicode.sh]]
  - [[#dmenuupdatesh][dmenuUpdate.sh]]
  - [[#dmenuvanillash][dmenuvanilla.sh]]
  - [[#dmenuwallpapersh][dmenuwallpaper.sh]]
  - [[#exitqtilesh][exitqtile.sh]]
- [[#other-scripts][Other scripts]]
  - [[#aandelenpy][aandelen.py]]
  - [[#bitcoin_notificationpy][bitcoin_notification.py]]
  - [[#bitcoin_email_botpy][bitcoin_email_bot.py]]
  - [[#stack_startupsh][stack_startup.sh]]
  - [[#decrmonitorbrightnesssh][decrMonitorBrightness.sh]]
  - [[#dotfilessh][dotfiles.sh]]
  - [[#kbswitch][kbswitch]]
  - [[#incrmonitorbrightnesssh][incrMonitorBrightness.sh]]
  - [[#nightcolordownsh][nightColorDown.sh]]
  - [[#nightcolorupsh][nightColorUp.sh]]
  - [[#notify-logsh][notify-log.sh]]
  - [[#unicode][unicode]]
  - [[#rdxswitch][rdxswitch]]
  - [[#resetrgbsh][resetRGB.sh]]
  - [[#screenshot2textsh][screenshot2text.sh]]
  - [[#stack_startupsh-1][stack_startup.sh]]
  - [[#thunarbookmarkssh][thunarBookmarks.sh]]
- [[#unused-scripts][Unused scripts]]
  - [[#aandelensh][aandelen.sh]]
  - [[#dwmbackupsh][dwmbackup.sh]]
  - [[#dwmbarsh][dwmbar.sh]]
  - [[#dwmpatchsh][dwmpatch.sh]]
  - [[#dwmstablesh][dwmstable.sh]]
  - [[#dwmvanillash][dwmvanilla.sh]]
  - [[#exitdwmsh][exitdwm.sh]]
  - [[#updatebarsh][updatebar.sh]]
  - [[#wololosh][wololo.sh]]
- [[#tips-and-tricks][Tips and tricks]]
  - [[#fetch-all-scrips-of-config-by-this-code-block][Fetch all scrips of ~/.config by this code block]]
  - [[#some-notes-about-the-code-blocks-and-tangling][Some notes about the code blocks and tangling.]]

* About this document
This document is a note-to-self about my scripts on my GNU/Linux system and is my attempt at [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] in [[https://www.gnu.org/software/emacs/][Emacs]] using org-mode. This README.org is the source file and is converted to the individual shell scripts by tangling in Emacs: ~M-x~ ~org-babel-tangle~.

* My dmenu scripts

** clipboard_dm.sh
A tool to show/save/open clipboards via dmenu. The clipboard contents are saved to Ram and will not be permanent, reboot will remove the data.

#+BEGIN_SRC bash :tangle clipboard_dm.sh :padline no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

#+BEGIN_SRC bash :tangle clipboard_dm.sh :padline no :tangle-mode (identity #o755)

# Define the clipboard directory, in the ram
clipboard_dir="$XDG_RUNTIME_DIR/temp/clipboard"

# Create the directory if it doesn't exist
mkdir -p "$clipboard_dir"

notify-send -t 60000 "Clipboard management opened"

while true; do
    # Use dmenu to choose an action from a list
    selected_action=$(echo -e "1. Show Current Clipboard\n2. Show List of Saved Clipboards\n3. Save Current Clipboard to List\n4. Select Clipboard from List. This will become new clipboard\n5. Modify Clipboard from List in Emacs\n6. Modify Current Clipboard in Emacs and save as 00_temp_clipboard.txt\n7. Delete Single Entry from List\n8. Exit" | dmenu -c -bw 2 -l 40 -p "Clipboard options: ")

    # Check if Escape was pressed or dmenu was closed
    if [[ -z "$selected_action" ]]; then
        notify-send -t 60000 "Exiting clipboard menu"
        exit 0
    fi

    case "$selected_action" in
        "1. Show Current Clipboard")
            # Get the current clipboard content
            current_clipboard=$(xclip -o -selection clipboard)

            # Show the current clipboard content using dmenu
            echo -n "$current_clipboard" | dmenu -c -bw 2 -l 60 -p "Current Clipboard:"
            ;;

       "2. Show List of Saved Clipboards")
            # List saved clipboard files using dmenu and choose a file
            selected_file=$(ls "$clipboard_dir" | dmenu -c -bw 2 -l 30 -p "Choose a file to show:")

            notify-send -t 60000 "Viewing $selected_file"
            # Check if the selected file exists
            if [[ -f "$clipboard_dir/$selected_file" ]]; then
                # Read the content of the selected file
                clipboard_content=$(cat "$clipboard_dir/$selected_file")

                # Extract the number from the filename
                filename_number="${selected_file%%_*}"

                # Show the content in dmenu with the number
                echo -n "$clipboard_content" | dmenu -c -bw 2 -l 60 -p "Clipboard Content (File $filename_number):"
                notify-send -t 60000 "Back to clipboard menu"
            else
                notify-send "File Not Found" "The selected file does not exist."
            fi
            ;;

        "3. Save Current Clipboard to List")
            # Get the highest number used in existing filenames
            highest_number=0
            for file in "$clipboard_dir"/*; do
                if [[ -f "$file" ]]; then
                    filename=$(basename "$file")
                    number="${filename%%_*}"
                    if [[ $number =~ ^0*([1-9][0-9]*)$ ]]; then
                        current_number="${BASH_REMATCH[1]}"
                        if ((current_number > highest_number)); then
                            highest_number=$current_number
                        fi
                    fi
                fi
            done

            # Calculate the next filename number with two digits
            next_number=$(printf "%02d" $((highest_number + 1)))

            # Use dmenu to get additional text for the filename
            additional_text=$(echo "" | dmenu -c -bw 2 -p "Enter additional text for the filename (without spaces):")

            # Generate the filename
            filename="${next_number}_${additional_text}.txt"

            # Get clipboard content
            clipboard_content=$(xclip -o -selection clipboard)

            # Save clipboard content to a file
            echo "$clipboard_content" > "$clipboard_dir/$filename"

            # Display a notification
            notify-send "Clipboard Saved" "Clipboard content saved to $clipboard_dir/$filename"
            ;;

        "4. Select Clipboard from List. This will become new clipboard")
            # List saved clipboard files using dmenu and choose a file
            selected_file=$(ls "$clipboard_dir" | dmenu -c -bw 2 -l 30 -p "Choose a clipboard file to copy to clipboard:")

            # Check if the selected file exists
            if [[ -f "$clipboard_dir/$selected_file" ]]; then
                # Read the content of the selected file
                clipboard_content=$(cat "$clipboard_dir/$selected_file")

                # Copy the content to clipboard
                echo -n "$clipboard_content" | xclip -i -selection clipboard
                notify-send "Clipboard Content Copied" "Clipboard content from $selected_file copied to clipboard."
            else
                notify-send "File Not Found" "The selected file does not exist."
            fi
            ;;

        "5. Modify Clipboard from List in Emacs")
            # List saved clipboard files using dmenu and choose a file to edit
            selected_file=$(ls "$clipboard_dir" | dmenu -c -bw 2 -l 30 -p "Choose a file to edit:")

            # Check if the selected file exists
            if [[ -f "$clipboard_dir/$selected_file" ]]; then
                # Open the selected file in Emacs for editing in the background
                emacsclient -n "$clipboard_dir/$selected_file" &
                exit 0
            else
                notify-send "File Not Found" "The selected file does not exist."
            fi
            ;;

        "6. Modify Current Clipboard in Emacs and save as 00_temp_clipboard.txt")
            # Get the current clipboard content
            current_clipboard=$(xclip -o -selection clipboard)

            # Save the current clipboard content to a temporary file in the clipboard_dir
            temp_file="$clipboard_dir/00_temp_clipboard.txt"
            echo "$current_clipboard" > "$temp_file"

            # Open the temporary file in Emacs for editing
            emacsclient -n "$temp_file" &

            # Exit the script to close dmenu
            exit 0
            ;;

        "7. Delete Single Entry from List")
            # List saved clipboard files using dmenu and choose a file to delete
            selected_file=$(ls "$clipboard_dir" | dmenu -c -bw 2 -l 30 -p "Choose a file to delete:")

            # Check if the selected file exists
            if [[ -f "$clipboard_dir/$selected_file" ]]; then
                # Use dmenu to confirm deletion
                confirm_delete=$(echo -e "No\nYes" | dmenu -c -bw 2 -p "Are you sure you want to delete '$selected_file'?")

                if [[ "$confirm_delete" == "Yes" ]]; then
                    # Delete the selected clipboard file
                    rm "$clipboard_dir/$selected_file"
                    notify-send "Clipboard Entry Deleted" "Clipboard entry '$selected_file' has been deleted."
                else
                    notify-send "Deletion Canceled" "Clipboard entry '$selected_file' was not deleted."
                fi
            else
                notify-send "File Not Found" "The selected file does not exist."
            fi
            ;;

        "8. Exit")
            exit 0
            ;;
    esac
done
#+END_SRC

** dmenuapps.sh
My app picker. A simple script to select which application to start via dmenu.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenuapps.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

A list of all of the installed applications is located in ~~/.cache/dmenu_run~ which is piped into dmenu. If this list is not already generated then run the shell script that is described in this org document called [[dmenuUpdate.sh]].
#+BEGIN_SRC bash :tangle dmenuapps.sh :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenuapps.sh" &&
chosen=$(cat $HOME/.cache/dmenu_run | dmenu -c -bw 2 -l 40 -p 'run: ') &&
notify-send -t 60000 "Starting application: " "$chosen" &&
$chosen

#+END_SRC

** dmenubackup.sh
Make a backup of the current dmenu version.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenubackup.sh :padline no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

The *_stable name will be the new stable version of dmenu.
#+BEGIN_SRC bash :tangle dmenubackup.sh :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenubackup.sh" &&
echo -n "Are you sure you want to make a backup of the current dmenu version? (y/n) "
read answer
if [ "$answer" != "${answer#[Yy]}" ] ;then
    rm -r $HOME/Stack/Dotfiles/dmenu/dmenu-distrotube_stable &&
    mkdir $HOME/Stack/Dotfiles/dmenu/dmenu-distrotube_stable &&
    cp -r $HOME/.config/suckless/dmenu/* ~/Stack/Dotfiles/dmenu/dmenu-distrotube_stable &&
    notify-send -t 60000 "Thank you. A backup of dmenu was made to"
else
    echo No
    notify-send -t 60000 "Exiting dmenubackup.sh" "No backup was made"
fi
#+END_SRC

** dmenuemacs.sh
Bookmarkst to textfiles picked by dmenu.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenuemacs.sh  :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

My list of textfiles is piped into dmenu and the selected one is opened in a new instance of emacs or on the already opened emacs client. Note: the 'textfile' is a textfiles that consists of a list of filenames including the directory location.
#+BEGIN_SRC bash :tangle dmenuemacs.sh  :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenuemacs.sh" &&
chosen=$(cat $HOME/Stack/Command_line/textfiles | dmenu -c -bw 2 -l 40 -p 'Open textfiles: ')
[ -z "$chosen" ] && exit
#+END_SRC

Then my running processes are checked and when an emacs instance if found running then the file is opened in that instance and otherwise emacs is opened.
#+BEGIN_SRC bash :tangle dmenuemacs.sh  :padline no :tangle-mode (identity #o755)
if pgrep -f "emacsclient -c -a emacs*" > /dev/null; then
  emacsclient -n "$chosen"
  emacsclient -e "(message \"Opened $chosen in Emacs\")" > /dev/null 2>&1
# emacclient -e '(message "Emacs is running")'
else
  emacsclient -c -a emacs "$chosen"
fi
#+END_SRC

** dmenuinternet.sh
Internet bookmark picking by dmenu.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenuinternet.sh  :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

My list of bookmarks ~~urls~ is piped into dmenu and the selected url is opened in the default browser application (~xdg-open~).
#+BEGIN_SRC bash :tangle dmenuinternet.sh  :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenuinternet.sh" &&
chosen=$(cat $HOME/Stack/Command_line/urls | dmenu -c -bw 2 -l 40 -p 'Open website: ')
[ -z "$chosen" ] && exit
xdg-open $chosen &&
notify-send -t 60000 "Opening webpage: " "$chosen"
#+END_SRC

** dmenukill.sh
Killing processes by dmenu, with menu options, use wisely!

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenukill.sh  :padline no :tangle-mode (identity #o755)
#!/usr/bin/env bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

#+BEGIN_SRC bash :tangle dmenukill.sh  :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenukill.sh, a script to kill processes!" &&
chosen="$(ps -a -u $USER |dmenu -c -bw 2 -l 40 -p "Delete process:"| awk '{print $1}')"
[ -z "$chosen" ] && exit
#pwd &&
#kill $chosen &
#notify-send -t 60000 "The process: $chosen was killed!"

A menu with four options is created to kill the selected process, copy process information to the clipboard or exit.
# Display options and read user choice
selected_option=$(echo -e "d Delete process\nc Copy process name\np Copy PID\ne Exit" | dmenu -c -bw 2 -l 4 -p "Choose an option:")
process_name=$(ps -p "$chosen" -o comm=)

case "$selected_option" in
    "d Delete process")
        kill "$chosen"
        notify-send -t 60000 "The process '$process_name' with PID '$chosen' was killed!"
        ;;
    "c Copy process name")
        echo "$process_name" | xclip -selection clipboard
        notify-send -t 60000 "Process name '$process_name', coupled to PID '$chosen', was copied to clipboard!"
        ;;
    "p Copy PID")
        echo "$chosen" | xclip -selection clipboard
        notify-send -t 60000 "Selected PID '$chosen', coupled to process name '$process_name', was copied to clipboard!"
        ;;
    "e Exit")
        notify-send -t 60000 "Exiting dmenukill.sh"
        exit
        ;;
esac
#+END_SRC

** dmenupatch.sh
Basic patch automation for dmenu. Make sure that the current version is saved as the stable version before running this script.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenupatch.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

This script will delete all of the current dmenu files. It will build from the stable version backup location.
1: delete files in test directory and restore the stable dmenu verstion.
2: write the diff filename to the diff_log
3: Run the patch

#+BEGIN_SRC bash :tangle dmenupatch.sh :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenupatch.sh" &&
echo -n "Are you sure you want to patch the current dmenu version? This will first:
RESTORE TO THE STABLE VERSION OF DMENU and after that make clean install on the .diff file in the direcotory ~/Stack/Dotfiles/dmenu/patches/test. Yes or no? (y/n) "
read answer
if [ "$answer" != "${answer#[Yy]}" ] ;then
    rm -r $HOME/.config/suckless/dmenu &&
    mkdir $HOME/.config/suckless/dmenu &&
    cp -r $HOME/Stack/Dotfiles/dmenu/dmenu-4.9_stable/* ~/.config/suckless/dmenu &&
    cd $HOME/.config/suckless/dmenu &&
    clear && ls -al
    ls $HOME/Stack/Dotfiles/dmenu/patches/test/*.diff >> ~/.config/suckless/dmenu/log/diff_log &&
    cp -r $HOME/.config/suckless/dmenu/config.h ~/.config/suckless/dmenu/config.def.h &&
    rm $HOME/.config/suckless/dmenu/config.h &&
    patch -p1 < $HOME/Stack/Dotfiles/dmenu/patches/test/*.diff &&
    make clean install
    notify-send -t 60000 "dmenu was patched"
else
    echo No
    notify-send -t 60000 "Exited dmenupatch.sh. Nothing was changed"
fi
#+END_SRC

** dmenustable.sh
Restore to the stable version of dmenu and remove the current version.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenustable.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

This script gives yes/no option to make a local backup of dmenu.
This script can be called by the .bashrc alias dmenustable.
#+BEGIN_SRC bash :tangle dmenustable.sh :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenustable" &&
echo -n "Are you sure you want to restore to the stable version and DELETE the current dmenu version? (y/n) "
read answer
if [ "$answer" != "${answer#[Yy]}" ] ;then
    rm -r $HOME/.config/suckless/dmenu &&
    mkdir $HOME/.config/suckless/dmenu &&
    cp -r $HOME/Stack/Dotfiles/dmenu/dmenu-distrotube_stable/* ~/.config/suckless/dmenu &&
    cd $HOME/.config/suckless/dmenu &&
    clear && ls -al
    notify-send -t 60000 "The stable version of dmenu was placed back" "Please run sudo make clean install"
else
    echo No
    notify-send -t 60000 "Exited dmenustable.sh. Nothing was changed"
fi
#+END_SRC

** dmenuthunar.sh
A dmenu script to give some directory options to open in the file manager Thunar.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenuthunar.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

Make sure that the list with directories options for Thunar are generated at ~~/.config/directories~.
If the bookmarks are not visible in Thunar then please generate them with [[thunarBookmarks.sh]].
This requires the dmenu patch: center, which gives the dmenu -c option.
After Thunar is launched there is a microbreak and then F3 is pressed to open l3ts
#+BEGIN_SRC bash :tangle dmenuthunar.sh :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenuthunar.sh" &&
chosen=$(cat $HOME/Stack/Command_line/directories | dmenu -c -bw 2 -l 40 -p 'Thunar open dir: ')
[ -z "$chosen" ] && exit
notify-send -t 60000 "Directory opened in Thunar: " "$chosen" &&
thunar $chosen & sleep .3 && xdotool key F3
#+END_SRC

** dmenuunicode.sh
Selecting âž¡emojisâ¬… via dmenu, ðŸ†’.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenuunicode.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

A list of unicode is piped into dmenu, up to a list of 45 lines. Then via ~awk~ the output is piped into the system clipboard and the output is pasted out directly. The backspace is added to remove the nextline. If the unicode file is missing then generate it by [[unicode]].
#+BEGIN_SRC bash :tangle dmenuunicode.sh :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenuunicode.sh" &&
cat $HOME/.config/unicode | dmenu -c -bw 2 -l 40 -p 'Emoji picker: '| awk '{print $1}'| xclip -selection clipboard &&
xdotool key "ctrl+v" "BackSpace" &&
notify-send -t 60000 "Emoji in clipboard: " "$(xclip -o -selection clipboard)"
#+END_SRC
Remark: the center patch of dmenu is needed for the -c option.

** dmenuUpdate.sh
Refreshing my list of installed applications. This list is used in dmenu as an app picker.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenuUpdate.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

First the old list of applications ~dmenu_run~ is deleted the names of the applications in ~/usr/bin~ are written in a new ~dmenu_run~ file.
#+BEGIN_SRC bash :tangle dmenuUpdate.sh :padline no :tangle-mode (identity #o755)
#notify-send -t 60000 "Running dmenuUpdate.sh" &&
rm $HOME/'.cache/dmenu_run' &
ls /usr/bin/* > $HOME/.cache/dmenu_run &&
#+END_SRC

Appimages are not part of ~/usr/bin~ and all of the appimages from $HOME/Applications are added to the ~dmenu_run~ list. These Appimages are writen to the top of the list.
#+BEGIN_SRC bash :tangle dmenuUpdate.sh :padline no :tangle-mode (identity #o755)
shopt -s nullglob # When AppImages aren't present then the loop will not be run
FILES=$HOME/Applications/*.AppImage
for f in $FILES
do
    sed -i '1 i '$f  $HOME/.cache/dmenu_run
done
notify-send -t 60000 "A new list of installed applications is made ðŸ˜ƒ"
#+END_SRC

** dmenuvanilla.sh
Return to the vanilla version of dmenu by this terminal script. This is typically used after patching and crashing ðŸ˜¢.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenuvanilla.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

First give the option to opt out and wait for the user to continue or not.
#+BEGIN_SRC bash :tangle dmenuvanilla.sh :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running dmenuvanilla.sh" &&
echo -n "Are you sure you want to restore to vanilla dmenu and DELETE the current dmenu version? (y/n) "
read answer
#+END_SRC

The 'live' version of dmenu is deleted from the ~~/.config/suckless/dmenu~ directory and the vanilla version is copied to the 'live' directory. After this dmenu is restored back to vanilla.
#+BEGIN_SRC bash :tangle dmenuvanilla.sh :padline no :tangle-mode (identity #o755)
if [ "$answer" != "${Ganswer#[Yy]}" ] ;then
    rm -r $HOME/.config/suckless/dmenu &&
    mkdir $HOME/.config/suckless/dmenu &&
    cp -r $HOME/Stack/Dotfiles/dmenu/dmenu-distrotube_14JAN22/* ~/.config/suckless/dmenu &&
    cd $HOME/.config/suckless/dmenu &&
    clear && ls -al
    notify-send -t 60000 "The vanilla version of dmenu was restored. Please run sudo make clean instsall" &&
else
    echo No
    notify-send -t 60000 "Exited dmenuvanilla.sh. Nothing was changed. "
fi
#+END_SRC

** dmenuwallpaper.sh
Script to select wallpapers via dmenu.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle dmenuwallpaper.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

This scripts pipes the files that are in the Wallpaper directory to dmenu. It requires the dmenu patch center, which gives the -c option. The selection from dmenu is piped into the clipboard which is usting it as standard out (not saved to clipboard) and then entered into the ~feh~ application to change the wallpaper.
The notify-send will send a notification, duh! The -t flag sets the time to show the notification in milliseconds. The left part between brackets will be displayed in bold and the second part between quotes will show in normal font. The cut program removes the directory information, which is 44 characters long.
The --bg-fill option makes sure that the image is stretched to the dimensions of the screen.
#+BEGIN_SRC bash :tangle dmenuwallpaper.sh :padline no :tangle-mode (identity #o755)
notify-send  "Running dmenuwallpaper.sh" &&
ls $HOME/Stack/Afbeeldingen/Wallpapers/*.* | dmenu -c -bw 2 -l 40 -p 'Wallpaper: ' | awk '{print $1}'| xclip -selection clipboard && feh --bg-fill "$(xclip -o -selection clipboard)" &&
notify-send -t 60000 "Wallpaper changed to: " "$(xclip -o -selection clipboard | cut -c 44-)"
#+END_SRC

** exitqtile.sh
Used to exit the Qtile windowmanager with yes/no option.

Any script should start with a directive, first a shebang ~#!~ and in this case a bash script is used.
#+BEGIN_SRC sh :tangle exitqtile.sh :padline no :eval no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

Echo out the options and run the ~killall qtile~ command, or not.
#+BEGIN_SRC sh :tangle exitqtile.sh :padline no :eval no :tangle-mode (identity #o755)
notify-send -t 60000 "Do you want to leave the system?"
choices=("Close Window Manager" "Reboot" "Shutdown")
colors="-nb #FFFFFF -nf #000000 -sb #DC5A5A -sf  #FFFFFF"  # Pale red background outside, red inside
chosen=$(printf '%s\n' "${choices[@]}" | dmenu -c -l "${#choices[@]}" $colors)


case "$chosen" in
    "Close Window Manager")
        # Command to close the window manager (qtile in this case)
        killall qtile
        notify-send -t 60000 "Closing down qtile!"
        ;;
    "Reboot")
        # Command to reboot the system
        systemctl reboot
        notify-send -t 60000 "Rebooting the system!"
        ;;
    "Shutdown")
        # Command to shut down the system
        systemctl poweroff
        notify-send -t 60000 "Shutting down the system!"
        ;;
    ,*)
        echo "No option selected."
        ;;
esac
#+END_SRC

* Other scripts
** aandelen.py
A script that makes an overview of my asset allocation and saves it to my clipboard. Two entries are manually made in an input dialog: cash amount and surplus value of my house. After that two csv files with portfolio information are opened, relevant information is extracted/sorted/calculated/formated-to-emacs-org-tables and saved to the clipboard.

Any script should start with a directive, first a shebang ~#!~ and in this case a python 3 scripts is used.
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
#!/usr/bin/env python3
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

The libraries that are used for this script are imported in the next section.
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
import glob, os, pyperclip, time
import pandas as pd
from PyQt5.QtWidgets import (QLineEdit, QDialog, QDialogButtonBox, QFormLayout, QApplication)
#+END_SRC

The ~InputDialog~ class is defined here, an input screen based on the PyQT5 library. This code is based on https://stackoverflow.com/questions/56019273/how-can-i-get-more-input-text-in-pyqt5-inputdialog. The aim is to add the amount of cash and surplus value of the house here by hand. After this the script takes over the heavy lifting.

#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
class InputDialog(QDialog):
    """Invoerscherm voor hoeveelheid geld en overwaarde huis"""

    def __init__(self, parent=None):
        super().__init__(parent)
        global Huis  # Zorg ervoor dat variabel buiten dialog te gebruiken is.
        global RaboCash  # Zorg ervoor dat variabel buiten dialog te gebruiken is.
        RaboCash = QLineEdit(self)
        Huis = QLineEdit(self)
        buttonbox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        layout = QFormLayout(self)
#        layout.addRow("Voer Rabo cash in (spaar+courant):", RaboCash)
        layout.addRow("Voer Bunq en Rabo cash in:", RaboCash)
        layout.addRow("Voer overwaarde huis in:", Huis)
        layout.addWidget(buttonbox)
        buttonbox.accepted.connect(self.accept)
        buttonbox.rejected.connect(self.reject)

    def getinputs(self):
        return RaboCash.text(), Huis.text()

if __name__ == '__main__':
    import sys
    app = QApplication(sys.argv)
    dialog = InputDialog()
    if dialog.exec():
        RaboCash, Huis = dialog.getinputs()
        Huis = int(Huis)          # Moet integer zijn voor latere berekening
        RaboCash = int(RaboCash)  # Moet integer zijn voor latere berekening
#+END_SRC

A function is created which will add data of a CSV file to a dataframe. The input is the filename of the CSV, the delimiter of the file (, or ;) and the column names. The column names are harmonized by the dfx.column
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
def AddCSVtoDataFrame(filename, delimiter, column1, column2):
    """Building a dataframe from several CSV files"""
    global df  # This dataframe will be used outside of this def, so make it global
    dfx = pd.read_csv(filename, thousands=r'.', sep=delimiter, usecols=[column1, column2])
    dfx.columns = [OmsCol, EurCol] # Harmonizing column names
    dfx[EurCol] = [x.replace(".", "") for x in dfx[EurCol]]  #  Removal of thousand separator
    dfx[EurCol] = [x.replace(",", ".") for x in dfx[EurCol]] #  Change comma to point
    dfx[EurCol] = (dfx[EurCol].astype(float)).apply(int)     # Change the Euro column to integer.
    df = pd.concat([df, dfx])    # Add the temp dataframe to dataframe
    print('=' * 40 + "\n", dfx)  # For debugging
#+END_SRC

The filenames and path of the csv files are generated here.
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
fileDeGIRO = os.path.expanduser("~") + "/Downloads/Portfolio.csv"
searchRabo = os.path.expanduser("~") + "/Downloads/Portefeuille_*"  # Wildcard searching
fileRabo = max(glob.iglob(searchRabo), key=os.path.getctime)        # Find newest file
#+END_SRC

Description of two asset allocation and column headers.
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
OmsHuis = "Overwaarde huis     "
OmsCash = "Cash (Rabo en Bunq) "
# Namen van kolommen die ik ga gebruiken:
EurCol = "Euro"                     # Euro column naam
OmsCol = "Omschrijving        "     # Omschrijving column naam
AaCol = "AA%"                       # Asset Allocation column naam
AminHuisCol = "AA*%"                # Asset Allocation zonder huis berekend column naam
#+END_SRC

Creation of dataframe and adding data of two portfolios to the dataframe.
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
df = pd.DataFrame() # Create a new dataframe
AddCSVtoDataFrame(fileRabo, ";", "Naam", "Huidig â‚¬") # Add data from csv files to dataframe
df.drop(3,0,inplace=True) # Remove the bottom row of the Rabobank CSV, it is empty
AddCSVtoDataFrame(fileDeGIRO, ",", "Waarde in EUR", "Product") # Add DeGIRO data to dataframe
# Create a new dataframe with surplus value house and Cash amount
d = {
    OmsCol: [OmsHuis, OmsCash],    # kolom omschrijving invullen
    EurCol: [Huis, RaboCash]}      # kolom euros invullen
dfx = pd.DataFrame(d)
# Samenvoegen van dataframes
df = pd.concat([df, dfx])
# Sorteer op euros, aflopend (ascending=False)
df = df.sort_values(by=EurCol, ascending=False)
#print('=' * 40 + "\n", df)  # Only for debugging
df = pd.DataFrame(df, columns=[OmsCol, EurCol, AaCol, AminHuisCol])
# Rangschik de volgorde van de kolommen en voeg nieuwe kolommen AA% en AA*% toe
#+END_SRC

Asset allocation calculation of percentages and adding of calculated values to the dataframe.
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
Kapitaal = df[EurCol].sum()  # Calculate the sum of all of the allocations (Kapitaal is Dutch for Capital)
# AA-berekening en de kolommen AA, en AA-huis omzetten naar integer
df[AaCol] = (df[EurCol] / Kapitaal * 100).astype(int) # Calculate values for column AaCol, % of total)
df[AminHuisCol] = (df[EurCol] / (Kapitaal - Huis) * 100).astype(int) # Calculate percentage, not taking into account the surplus value of the house
df.loc[df[AminHuisCol] > 100, AminHuisCol] = "*"  # If >100% then replace by asterix
#print('=' * 40  + "\n", dfx)                      # Only for debugging
#+END_SRC

Create a new temporary dataframe which become another org table with only the total amount of assets and the total amound of assets minus the surplus of the house.
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
# Nieuw dataframe aanmaken met streepjes en totale assets enz
d = {
    EurCol: ["" , Kapitaal, Kapitaal - Huis],
    OmsCol: ["" , "Assets totaal       ", "Assets totaal - huis  "],
    AaCol: ["", "", ""],
    AminHuisCol: ["", "", ""]}
dfx = pd.DataFrame(d)       # Add the list to a new temporary dataframe
df = pd.concat([df, dfx])   # Add the dfx dataframe
#print('=' * 40 + "\n", df)  # Only for debugging

df[OmsCol] = df[OmsCol].apply(lambda x: x[:20]) # Slim the "OmsCol" to 20 characters
#+END_SRC

Creation of an introduction line that contains org headers (*****), date and the assets total (minus surplus of house).
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
datum = time.strptime(time.ctime(os.path.getctime(fileDeGIRO))) # Search date of file: fileDeGIRO
t_stamp =   str(time.strftime("%Y", datum) + "-" + str(time.strftime("%m", datum)) + "-" +  str(time.strftime("%d", datum))) # Create a timestap (YYYYMMDD)

titel = ("\n" '*** <' + t_stamp + "> Assets(zonder huis): " + (Kapitaal - Huis).astype(str) + " Euro." "\n" + "\n")
#print('\n\n') # Only for debugging
#+END_SRC

The next part of the code is about getting the format ready to import in org, with a table format, the alignment is not complete, but can be easily done by a tab in org mode after pasting the data....
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
# Create a title for the org table, with three stars for level three heading
orgTabelNaam=('#+Name: tbl_', str(t_stamp), '\n')
orgTabelNaam=''.join(orgTabelNaam)

# Transform dataframe to a text string that is ready for the Emacs org-mode (with | separators)
gesorteerdeLijst = df.to_string(index=False)   # Index verwijderen van dataframe en string maken
gesorteerdeLijst = gesorteerdeLijst.replace('NaN', '')      # Replace NaN values
gesorteerdeLijst = (gesorteerdeLijst.replace("  ", "|"))    # Add separators
gesorteerdeLijst = (gesorteerdeLijst.replace("||", "|"))    # Remove duplicates
gesorteerdeLijst = (gesorteerdeLijst.replace("||", "|"))
gesorteerdeLijst = (gesorteerdeLijst.replace("||", "|"))
gesorteerdeLijst = '|'.join((gesorteerdeLijst.splitlines(True)))
separator= ('|-|-|-|-|') # separator for Emacs org mode (tables)

#print ('\n' + gesorteerdeLijst + '\n')
# Combineer de introductieregels met het dataframe
data = titel + orgTabelNaam + separator + '\n' + gesorteerdeLijst + '\n' + separator # Combineren van introductieregels+dataframe
data = data.replace('Omschrijving', '|Omschrijving')
data = data.replace('AA% AA*%', 'AA% |AA*% ')
data = data.replace('Euro AA%', 'Euro |AA%')
data = data.replace('||||', str(separator)+'\n\n'+str(separator)) # scheiding van twee tabellen
data = data.replace('|Overwaarde', str(separator)+'\n| Overwaarde ')
data = data.replace('|VANECK', 'VANECK')
data = data.replace('- huis', '- huis|')
#print('=' * 40 + "\n", "nieuwe data ---> clipboard:", data, sep="\n")  # Only for debugging
#+END_SRC

Writing the data to the clipboard and garbage collection.
#+BEGIN_SRC python :tangle aandelen.py :padline yes :tangle-mode (identity #o755)
pyperclip.copy(data)

del(AaCol, df, dfx, separator, gesorteerdeLijst, d, data, datum, t_stamp,
    orgTabelNaam, AminHuisCol, EurCol, Huis, Kapitaal, OmsCash, OmsCol,
    OmsHuis, RaboCash, fileDeGIRO, fileRabo, searchRabo, titel)
#+END_SRC

** bitcoin_notification.py
A simple Python script to fetch current bitcoin price, in euros, and date and placing output in the notifications. No API key needed.

#+BEGIN_SRC python :results none :tangle bitcoin_notification.py :padline yes :tangle-mode (identity #o755)
#!/usr/bin/env python3
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

The libraries that are used for this script are imported in the next section.
#+BEGIN_SRC python :results none :tangle bitcoin_notification.py :padline yes :tangle-mode (identity #o755)
import requests
import json
from datetime import datetime
from notifypy import Notify
#+END_SRC

Fetching information from the coingecko api, without a key.
#+BEGIN_SRC python :results none :tangle bitcoin_notification.py :padline yes :tangle-mode (identity #o755)
def coingecko():
    url = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=eur&include_last_updated_at=true"

    response = requests.get(url)

    if response.status_code == 200:
        data = response.json()
        rate = data["bitcoin"]["eur"]
        timestamp = data["bitcoin"]["last_updated_at"] # get timestamp
        date_time = datetime.fromtimestamp(timestamp)  # convert to an datetime object
        time = date_time.strftime("%H:%M:%S %d%h%y")   # convert to string
    else:
        rate = time = "Error fetching data"
    return (rate, time)  #NOTE: added because I want to use it in another script.
#+END_SRC

Funtion that will output the rate and time in the notification area.
#+BEGIN_SRC python :results none :tangle bitcoin_notification.py :padline yes :tangle-mode (identity #o755)
def output_to_notifications(rate, time):
    notification = Notify()
    notification.title = "Bitcoin price (euro):"
    notification.message = rate, time
    notification.send()
#+END_SRC

Now let's run the functions ðŸ˜€.
#+BEGIN_SRC python :results none :tangle bitcoin_notification.py :padline yes :tangle-mode (identity #o755)
coingecko()
fetch_coingecko_info = coingecko()
rate = fetch_coingecko_info[0]
time = fetch_coingecko_info[1]
output_to_notifications(rate, time)
#+END_SRC

** bitcoin_email_bot.py
A Python script that will email an alarm when the bitcoin price will reaches a certain level. The idea is to schedule this script with a systemd timer (or cron job).

First a disclaimer to only edit the file from org-mode.
#+BEGIN_SRC python :results none :tangle bitcoin_email_bot.py :padline yes :tangle-mode (identity #o755)
#!/usr/bin/env python3
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

The libraries that are used for this script are imported in the next section. Including the coingecko function from my bitcoin_notification.
#+BEGIN_SRC python :results none :tangle bitcoin_email_bot.py :padline yes :tangle-mode (identity #o755)
import os, configparser, smtplib, ssl
from bitcoin_notification import coingecko
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
#+END_SRC

The following fuction =get_info= will fetch relevant information from a textfile. For instance the email recipient address.
#+BEGIN_SRC python :results none :tangle bitcoin_email_bot.py :padline yes :tangle-mode (identity #o755)
def get_info():
    # Fetching email information from a local textfile.
    print("start van functie get_info")
    # Create a ConfigParser object
    config = configparser.ConfigParser()

    file_link = os.path.expanduser("~") + "/Stack/Command_line/settings_for_bitcoin_alarm"

    # Read the configuration file
    config.read(file_link)

    # Get the values from the configuration file
    global port, smtp_server, sender_email, password_email, receiver_email, bitcoin_target_price
    port = config.getint('email_config', 'port')
    smtp_server = config.get('email_config', 'smtp_server')
    sender_email = config.get('email_config', 'sender_email')
    password_email = config.get('email_config', 'password_email')
    receiver_email = config.get('email_config', 'receiver_email')
    bitcoin_target_price = config.getint('bitcoin_info', 'bitcoin_target_price')
#+END_SRC

Another function, =send_email=, will send the email if the bitcoin price reached a treshhold value.
#+BEGIN_SRC python :results none :tangle bitcoin_email_bot.py :padline yes :tangle-mode (identity #o755)
def send_email():
    # Compose the email message
    print("start van functie send_email")
    bitcoin_current_price = fetch_coingecko_info[0] # get current bitcoin price
    subject = "Let op: verkopen"
    message_body = f"""Goed nieuws!

    Mijn Bitcoin threshold prijs van {bitcoin_target_price} euro is gehaald! Dat betekend dat ik een gedeelte moet verkopen!
    Ter info: de prijs om {fetch_coingecko_info[1]} was {bitcoin_current_price} euro.

    Groetjes,
    email-bot
    """
    print("message:", message_body)
    print("bitcoin current price:", bitcoin_current_price )
    print("bitcoin target price:", bitcoin_target_price)
    # Create the email message
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = receiver_email
    message['Subject'] = subject
    message.attach(MIMEText(message_body, 'plain'))

    # Connect to the SMTP server
    try:
        # Connecting to SMTP server
        context = ssl.create_default_context()
        server = smtplib.SMTP_SSL(smtp_server, port, context=context)
        server.login(sender_email, password_email)

        # Check if the Bitcoin price is higher the target price and send email if so
        if bitcoin_current_price<bitcoin_target_price:
            print("de prijs is te laag helaas...")
        else:
            print("Yes! De prijs is goed, verstuur email")
            server.sendmail(sender_email, receiver_email, message.as_string())
            server.quit()
            print("Email sent successfully!")
    except Exception as e:
        print(f"An error occurred: {str(e)}")
#+END_SRC

And finally I call the functions here
#+BEGIN_SRC python :results none :tangle bitcoin_email_bot.py :padline yes :tangle-mode (identity #o755)
get_info()
fetch_coingecko_info = coingecko() #
print("Info van coingecko, rate:", fetch_coingecko_info[0])
print("Info van coingecko, time:", fetch_coingecko_info[1])
send_email()
#+END_SRC

** stack_startup.sh
A script to run the latest AppImage of Stack. Note: make sure that only one version is in the directory! It is used in my qtile configuration autostart shell script.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle stack_startup.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

First the directory of my AppImages is set and then the name of the AppImage is retrieved. A if-then-else statement that will choose to run the program or not and send the appropriate notification.
#+BEGIN_SRC bash :tangle stack_startup.sh :padline no :tangle-mode (identity #o755)
dir="$HOME/Applications" # directory
appimage=$(find "$dir" -name "*stack*.AppImage" -print -quit)

if [ -n "$appimage" ]; then
    notify-send -t 60000 "Starting the Stack .AppImage..." && #send notification
    "$appimage"  # Execute the file
else
    notify-send -t 60000 "No .AppImage file containing 'stack' in its name was found in $dir"
fi
#+END_SRC

** decrMonitorBrightness.sh
Decrease the monitor brightness by xrandr and also make the color more red. It's brother, [[incrMonitorBrightness.sh]], is a similar script doing the oposite.

Any script should start with a directive, first a shebang ~#!~ and in this case a bash script is used.
#+BEGIN_SRC sh :tangle decrMonitorBrightness.sh :padline no :eval no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

Information is retrieved from xrandr about the connected monitor and the current brightness and RGB values (gamma_value).
#+BEGIN_SRC sh :tangle decrMonitorBrightness.sh :padline no :eval no :tangle-mode (identity #o755)
monitor=$(xrandr | awk '/ connected/ {print $1}')
currentBrightness=$(xrandr --verbose | awk '/Brightness/ { print $2; exit }')
gamma_value=$(xrandr --verbose | awk '/^\s*Gamma:./ {print $NF}')
#+END_SRC

The RGB values are separated into the individual values and the green and blue values are multiplied by 0.9 to get a lower number. The three numbers are used to create a new RGB setting which is called "new_gamma_value".
#+BEGIN_SRC sh :tangle decrMonitorBrightness.sh :padline no :eval no :tangle-mode (identity #o755)
IFS=':' read -r gamma_r gamma_g gamma_b <<< "$gamma_value"
new_gamma_r=$(echo "1/$gamma_r" | bc -l)
new_gamma_g=$(echo "1/$gamma_g * 0.9" | bc -l)
new_gamma_b=$(echo "1/$gamma_b * 0.9" | bc -l)
new_gamma_value=$(printf "%.2f:%.2f:%.2f" "$new_gamma_r" "$new_gamma_g" "$new_gamma_b")
#+END_SRC

When the brightness reaches 0.1 then it should not be any lower, therefore and if-else statement is applied. The newBrightness is calculated to be -0.1 lower then the currentBrightness, this is calculated by the bc program.
#+BEGIN_SRC sh :tangle decrMonitorBrightness.sh :padline no :eval no :tangle-mode (identity #o755)
if [[ "$currentBrightness" == "0.10" ]] ; then
    echo "The current brightness is 0.1 and should not be any lower!"
    notify-send -t 60000 "ðŸ”† Brightness minimum reached!: ï¸" "$currentBrightness"
else
    newBrightness=$(echo $currentBrightness-0.1| bc -l)
    xrandr --output $monitor --brightness $newBrightness --gamma "$new_gamma_value"
    notify-send -t 60000 "ðŸ”† Brightness set to: $newBrightness RGB set to: $new_gamma_value"ï¸
    echo "Brightness changed from $currentBrightness  to $newBrightness. RGB change from $gamma_value to $new_gamma_value"
fi
#+END_SRC

** dotfiles.sh
A script to manage my dotfiles git repo. It checks the status of my dotfiles and gives options how to continue (push/pull/pullpush/exit).

Any script should start with a directive, first a shebang ~#!~ and in this case a shell script is used.
#+BEGIN_SRC sh :tangle dotfiles.sh :padline no :eval no :tangle-mode (identity #o755)
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#!/bin/bash
#+END_SRC

Two functions are declared; one to push to git and one to pull. The push function contains a commit message that, just because I'm lazy and commit messages for dotfiles are not that necessary.
#+BEGIN_SRC sh :tangle dotfiles.sh :padline no :eval no :tangle-mode (identity #o755)
# ~/.config/dotfiles.sh

notify-send -t 60000 "Running dotfiles.sh" &&
function Push()
{
/usr/bin/git --git-dir=$HOME/dotfiles/ --work-tree=$HOME add -u :/ -v;
/usr/bin/git --git-dir=$HOME/dotfiles/ --work-tree=$HOME commit -m "Updated";
/usr/bin/git --git-dir=$HOME/dotfiles/ --work-tree=$HOME push -v
}

function Pull()
{
/usr/bin/git --git-dir=$HOME/dotfiles/ --work-tree=$HOME reset --hard;
/usr/bin/git --git-dir=$HOME/dotfiles/ --work-tree=$HOME pull
}
#+END_SRC

The screen of the terminal is cleared and the status of dotfiles is checked. Then a menu is given in the terminal for the 4 options.
#+BEGIN_SRC sh :tangle dotfiles.sh :padline no :eval no :tangle-mode (identity #o755)
clear &&
/usr/bin/git --git-dir=$HOME/dotfiles/ --work-tree=$HOME status &&
echo -n "--------------------------------------------------
Please read the status of the dotfiles carefully above.

Options:
 1 commit/push
 2 pull (and first reset -hard)
 3 pull and a commit/push
 4 exit
[$USER@github.com/Prutserdt/dotfiles ~]:> "
#+END_SRC

The read command will take the imput that the user gives from within the terminal and the case statement will perform the push/pull/exit commands. That's all.
#+BEGIN_SRC sh :tangle dotfiles.sh :padline no :eval no :tangle-mode (identity #o755)
read PullPush
case $PullPush in
            [1])
                echo --------------------------------------------------
                echo
                Push
                notify-send -t 60000 "Push performed on the Github dotfiles repository"
                ;;
            [2])
                echo --------------------------------------------------
                echo
                Pull
                notify-send -t 60000 "Pull performed on the Github dotfiles repository"
                ;;
            [3])
                echo --------------------------------------------------
                echo
                Pull
                Push
                notify-send -t 60000 "Pull and Push performed on the Github dotfiles repository"
                ;;
            [4])
                echo --------------------------------------------------
                echo
                echo As you whish: exiting
                notify-send -t 60000 "Exited the dotfiles synchronization with Github"
                ;;

            *)  echo --------------------------------------------------
                echo
                echo "Invalid input, exiting"
                notify-send -t 60000 "Invalid input added during the dotfiles synchronization with Github"
            ;;
esac
#+END_SRC

** kbswitch
These settings are used in combination with an xmodmap command and can be used when a normy keyboard is used. It will swap Escape/CapsLock, change the super key to super left and super right and the same for the alt key (switch to alt-left and alt-right)
I run it by the alias ~~k~~ in my terminal which will execute ~xmodmap ~/.config/kbswitch~.

Swap the Escape with the Capslock.
#+BEGIN_SRC sh :tangle kbswitch :padline no :eval no
! NOTE: This file is generated from ~/.config/README.org
!       Please only edit that file and org-babel-tangle (emacs)
remove Lock = Caps_Lock
keysym Escape = Caps_Lock
keysym Caps_Lock = Escape
add Lock = Caps_Lock
#+END_SRC

Change the setting so that the left and right super keys are both functional. More modifiers is better...
#+BEGIN_SRC sh :tangle kbswitch :padline no :eval no
remove mod4 = Super_R
add mod3 = Super_R
#+END_SRC

The same thing for the alt key. Let's use the Alt-left and Alt-right.
#+BEGIN_SRC sh :tangle kbswitch :padline no :eval no
! In Manjaro 2022 the Alt_R key is ISO_Level3_Shift, uncomment next lines if needed.
!remove mod1 = ISO_Level3_Shift
!add mod5 = ISO_Level3_Shift
remove mod1 = Alt_R
add mod5 = Alt_R
#+END_SRC

** incrMonitorBrightness.sh
Increase the monitor brightness by xrandr and also make the color less red. It's sister, [[decrMonitorBrightness.sh]], is a similar script doing the oposite.

Any script should start with a directive, first a shebang ~#!~ and in this case a bash script is used.
#+BEGIN_SRC sh :tangle incrMonitorBrightness.sh :padline no :eval no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

Information is retrieved from xrandr about the connected monitor and the current brightness and RGB values (gamma_value).
#+BEGIN_SRC sh :tangle incrMonitorBrightness.sh :padline no :eval no :tangle-mode (identity #o755)
monitor=$(xrandr | awk '/ connected/ {print $1}')
currentBrightness=$(xrandr --verbose | awk '/Brightness/ { print $2; exit }')
gamma_value=$(xrandr --verbose | awk '/^\s*Gamma:./ {print $NF}')
#+END_SRC

The RGB values are separated into the individual values and the green and blue values are multiplied by 0.9 to get a lower number. The three numbers are used to create a new RGB setting which is called "new_gamma_value".
#+BEGIN_SRC sh :tangle incrMonitorBrightness.sh :padline no :eval no :tangle-mode (identity #o755)
IFS=':' read -r gamma_r gamma_g gamma_b <<< "$gamma_value"
new_gamma_r=$(echo "1/$gamma_r" | bc -l)
new_gamma_g=$(echo "1/$gamma_g * 1.1" | bc -l)
new_gamma_b=$(echo "1/$gamma_b * 1.1" | bc -l)
new_gamma_value=$(printf "%.2f:%.2f:%.2f" "$new_gamma_r" "$new_gamma_g" "$new_gamma_b")
#+END_SRC

When the brightness reaches 1 then it should not be any lower, therefore and if-else statement is applied. NOTE: when this is reached then the RGB is reset to 1:1:1 as well. The newBrightness is calculated to be +0.1 lower then the currentBrightness, this is calculated by the bc program.
#+BEGIN_SRC sh :tangle incrMonitorBrightness.sh :padline no :eval no :tangle-mode (identity #o755)
if [[ "$currentBrightness" == "1.0" ]] ; then
    echo "niets doen, want grens van 1.0 bereikt"
    xrandr --output $monitor --brightness 1.0 --gamma "1:1:1"
    notify-send -t 60000 "ðŸ”† Brightness maximum already reached! âš "
else
    newBrightness=$(echo $currentBrightness+0.1| bc -l)
    xrandr --output $monitor --brightness $newBrightness --gamma "$new_gamma_value"
    notify-send -t 60000 "ðŸ”† Brightness set to: $newBrightness RGB set to: $new_gamma_value"ï¸
    echo "Brightness changed from $currentBrightness  to $newBrightness. RGB change from $gamma_value to $new_gamma_value"
fi
#+END_SRC

** nightColorDown.sh
A script to make the screen more reddish. See the related [[nightColorUp.sh]], [[resetRGB.sh]] and also [[decrMonitorBrightness.sh]] [[incrMonitorBrightness.sh]].

Any script should start with a directive, first a shebang ~#!~ and in this case a bash script is used.
#+BEGIN_SRC sh :tangle nightColorDown.sh :padline no :eval no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

Get the current individual Red/Green/Blue gamma values.
#+BEGIN_SRC sh :tangle nightColorDown.sh :padline no :eval no :tangle-mode (identity #o755)
gamma_value=$(xrandr --verbose | awk '/^\s*Gamma:./ {print $NF}')
echo "Gamma value: $gamma_value is currently used"
IFS=':' read -r gamma_r gamma_g gamma_b <<< "$gamma_value"
#+END_SRC

Calculate the new gamma values. NOTE: the 1/ is needed because of an bug in xrandr, see https://gitlab.freedesktop.org/xorg/app/xrandr/-/issues/33
#+BEGIN_SRC sh :tangle nightColorDown.sh :padline no :eval no :tangle-mode (identity #o755)
new_gamma_r=$(echo "1/$gamma_r" | bc -l)
new_gamma_g=$(echo "1/$gamma_g * 1.1" | bc -l)
new_gamma_b=$(echo "1/$gamma_b * 1.1" | bc -l)
new_gamma_value=$(printf "%.2f:%.2f:%.2f" "$new_gamma_r" "$new_gamma_g" "$new_gamma_b")
#+END_SRC

Apply the new gamma values. The awk connected part makes shure that the right output is selected, then the script will work on any connnected display.
#+BEGIN_SRC sh :tangle nightColorDown.sh :padline no :eval no :tangle-mode (identity #o755)
xrandr --output $(xrandr | awk '/ connected/ {print $1}') --gamma "$new_gamma_value"
echo "New gamma value, after xrandr: $new_gamma_value"
notify-send -t 60000 "ðŸ”† Red decreased to: " "$new_gamma_value"ï¸
#+END_SRC

** nightColorUp.sh
A script to make the screen more reddish. See the related [[nightColorDown.sh]], [[resetRGB.sh]] and also [[incrMonitorBrightness.sh]], [[decrMonitorBrightness.sh]].

Any script should start with a directive, first a shebang ~#!~ and in this case a bash script is used.
#+BEGIN_SRC sh :tangle nightColorUp.sh :padline no :eval no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

Get the current individual Red/Green/Blue gamma values.
#+BEGIN_SRC sh :tangle nightColorUp.sh :padline no :eval no :tangle-mode (identity #o755)
gamma_value=$(xrandr --verbose | awk '/^\s*Gamma:./ {print $NF}')
echo "Gamma value: $gamma_value is currently used"
IFS=':' read -r gamma_r gamma_g gamma_b <<< "$gamma_value"
#+END_SRC

Calculate the new gamma values. NOTE: the =1/gamma= is needed because of an bug in xrandr, see https://gitlab.freedesktop.org/xorg/app/xrandr/-/issues/33
#+BEGIN_SRC sh :tangle nightColorUp.sh :padline no :eval no :tangle-mode (identity #o755)
new_gamma_r=$(echo "1/$gamma_r" | bc -l)
new_gamma_g=$(echo "1/$gamma_g * 0.9" | bc -l)
new_gamma_b=$(echo "1/$gamma_b * 0.9" | bc -l)
new_gamma_value=$(printf "%.2f:%.2f:%.2f" "$new_gamma_r" "$new_gamma_g" "$new_gamma_b")
#+END_SRC

Apply the new gamma values. The awk connected part makes shure that the right output is selected, then the script will work on any connnected display.
#+BEGIN_SRC sh :tangle nightColorUp.sh :padline no :eval no :tangle-mode (identity #o755)
xrandr --output $(xrandr | awk '/ connected/ {print $1}') --gamma "$new_gamma_value"
echo "New gamma value, after xrandr: $new_gamma_value"
notify-send -t 60000 "ðŸ”† Red increased to: " "$new_gamma_value"ï¸
#+END_SRC

** notify-log.sh
This script will write the notifications to a logfile. The script is used by running ~$HOME/.config/notify-log.sh $HOME/.config/notify.log~

Any script should start with a directive, first a shebang ~#!~ and in this case a bash script is used.
#+BEGIN_SRC sh :tangle notify-log.sh :padline no :eval no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

#+BEGIN_SRC sh :tangle notify-log.sh :padline no :eval no :tangle-mode (identity #o755)

logfile=$1 # Next entree after shell script will become the logfile: *.sh ~HOME/.config/notify.log

declare -a MSGBUF
STATE=off
MSGTIME=

printbuf() {
  JOINED=$( echo "${MSGBUF[@]}" | sed 's/,$//' )
  printf "%s\n%s\n" "--- ${MSGTIME} ---" "${JOINED}"
}

procmsg() {
  if [[ "${1}" =~ member=Notify$ ]]; then
    STATE=on
    MSGTIME=$(date '+%Y-%m-%d %H:%M:%S')
    MSGBUF=()
  elif [[ "${1}" =~ member=NotificationClosed$ ]]; then
    STATE=off
    printbuf
  else
   if [[ "${STATE}" == "on" ]]; then
      if [[ "${1}" =~ ^string ]]; then
        case "${1}" in
          "string \"\"") ;;
          "string \"urgency\"") ;;
          "string \"sender-pid\"") ;;
          ,*)
            MSGBUF+=$( echo -n "${1}," )
          ;;
        esac
      fi
    fi
  fi
}

dbus-monitor "interface='org.freedesktop.Notifications'" | \
    while read -r line; do
      procmsg "$line" >> "$logfile"
    done

#+END_SRC

** unicode
Create a list of emojis that is used in [[dmenuunicode.sh]] by first downloading the current unicode list by wget.
#+BEGIN_SRC bash
wget https://unicode.org/Public/emoji/15.0/emoji-test.txt
#+END_SRC

Open the text file in emacs and remove the left part of the lines up to the emoji visual block selection and deletion. After that the empty lines were removed by ~:g/^$/d~. The document was saved as ~~/.config/unicode~.
Or copy an existing lists online, like this one of [[https://github.com/LukeSmithxyz/voidrice/blob/master/.local/share/larbs/emoji][Luke Smith]].

** rdxswitch
These settings are used in combination with an xmodmap command and are restoring the keysetting that I use for my Redox keyboard. I run it by the alias ~r~ in my terminal which will execute ~xmodmap ~/.config/rdxswitch~. This is needed when keyboards are swapped.

My Redox firmware has the escape button to the left of the 'A' button, like it should be!. When previously a keyboard with other mapping is used, and the escape/capslock is changed then it is in the wrong position and this can be corrected by this setting
#+BEGIN_SRC sh :tangle rdxswitch :padline no :eval no
! NOTE: This file is generated from ~/.config/README.org
!       Please only edit that file and org-babel-tangle (emacs)
remove Lock = Caps_Lock
keysym Escape = Escape
keysym Caps_Lock = Caps_Lock
add Lock = Caps_Lock
#+END_SRC

With my custom redox build there is a Super-R.  Remove right super key and make it another mod key (for opening apps)
#+BEGIN_SRC sh :tangle rdxswitch :padline no :eval no
remove mod4 = Super_R
! add the keycode that you are going to use for the Super_R. 400 ms on redox keyboard: keycode 134
keycode 134 = Super_R
! add the keycode that you are going to use for the Super_R. PrtSc: keycode 107 (Lenode Thinkpad X270)
!keycode 107 = Super_R
! Connect mod3 to be Super_R:
add mod3 = Super_R
#+END_SRC

** resetRGB.sh
Reset the gamma settings (RGB) to a default value of 1:1:1. Related to the shell scripts [[nightColorUp.sh]] and [[nightColorDown.sh]].

Any script should start with a directive, first a shebang ~#!~ and in this case a bash script is used.
#+BEGIN_SRC sh :tangle resetRGB.sh :padline no :eval no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

Apply the new gamma values. The awk connected part makes shure that the right output is selected, then the script will work on any connnected display.
#+BEGIN_SRC sh :tangle resetRGB.sh :padline no :eval no :tangle-mode (identity #o755)
xrandr --output $(xrandr | awk '/ connected/ {print $1}') --gamma 1:1:1
notify-send -t 60000 "ðŸ”† RGB reset!"
#+END_SRC

** screenshot2text.sh
A script that makes a screenshot and magically converts it to text in the system clipboard. I use it with the keybinding shift-printscreen.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle screenshot2text.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

A temporary directory is made in the system RAM. The files for this script will be stored there. The advantage is that RAM is very quick for read/writing and after a reboot the files are gone. There is no need to save these files.
#+BEGIN_SRC bash :tangle screenshot2text.sh :padline no :tangle-mode (identity #o755)
mkdir $XDG_RUNTIME_DIR/temp &
#+END_SRC

The screenshot program xfce4-screenshooter ~-r~ flag will select a region to be captured by mouse and the ~-s~ flag will save to the path. Here the ~$XDG_RUNTIME_DIR/temp~ is selected and the screenshot is saved as 'wismij.jpg' =(wismij is Dutch for EraseMe)=. NOTE: the next screenshot will overwrite the jpg and txt file.
#+BEGIN_SRC bash :tangle screenshot2text.sh :padline no :tangle-mode (identity #o755)
notify-send -t 60000 "Running screenshot2text" "Select an area with mouse ðŸ­ to convert to text" &&
xfce4-screenshooter -r -s $XDG_RUNTIME_DIR/temp/wismij.jpg &&
#+END_SRC

The tesseract program is converting the picture to text and is saved in the RAM directory as 'wismij', which is actually 'wismij.txt'.
#+BEGIN_SRC bash :tangle screenshot2text.sh :padline no :tangle-mode (identity #o755)
tesseract $XDG_RUNTIME_DIR/temp/wismij.jpg $XDG_RUNTIME_DIR/temp/wismij &&
#+END_SRC

Finally the textfile is catted and piped to the system clipboard with xclip. The -sel flag selects the X selection to use and ~clip~ stands for clipboard, where the text will be stored. Ready to be pasted when needed.
#+BEGIN_SRC bash :tangle screenshot2text.sh :padline no :tangle-mode (identity #o755)
cat $XDG_RUNTIME_DIR/temp/wismij.txt | xclip -sel clip &&
notify-send -t 60000 "Text created from screenshot" "$(cat $XDG_RUNTIME_DIR/temp/wismij.txt)"
#+END_SRC

** stack_startup.sh
A script to run the latest AppImage of Stack. Note: make sure that only one version is in the directory! It is used in my qtile configuration autostart shell script.

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle stack_startup.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

First the directory of my AppImages is set and then the name of the AppImage is retrieved. A if-then-else statement that will choose to run the program or not and send the appropriate notification.
#+BEGIN_SRC bash :tangle stack_startup.sh :padline no :tangle-mode (identity #o755)
dir="$HOME/Applications" # directory
appimage=$(find "$dir" -name "*stack*.AppImage" -print -quit)

if [ -n "$appimage" ]; then
    notify-send -t 60000 "Starting the Stack .AppImage..." && #send notification
    "$appimage"  # Execute the file
else
    notify-send -t 60000 "No .AppImage file containing 'stack' in its name was found in $dir"
fi
#+END_SRC

** thunarBookmarks.sh
A script that converts the directory text files (~/Stack/Command_line/directories) to a Thunar bookmarks text file (~/.config/gtk-3.0/bookmarks).

Any script should start with a directive, first a shebang ~#!~ and to be POSIX compliant I choose ~sh~ here.
#+BEGIN_SRC bash :tangle thunarBookmarks.sh :padline no :tangle-mode (identity #o755)
#!/bin/sh
# NOTE: This file is generated from ~/.config/README.org
#       Please only edit that file and org-babel-tangle (emacs)
#+END_SRC

This script reads in each line of the directories file using a while read loop, and for each directory it appends a corresponding bookmark to the bookmarks file using echo. Note that we prefix the directory path with file:// to format it as a valid bookmark path.
#+BEGIN_SRC bash :tangle thunarBookmarks.sh :padline no :tangle-mode (identity #o755)

# Set the paths to the directories file and the bookmarks file
DIR_FILE=$HOME/Stack/Command_line/directories
BOOKMARKS_FILE=$HOME/.config/gtk-3.0/bookmarks

# Loop through each directory in the directories file
#while read -r; do
while read -r dir; do
    # Convert the directory path to a bookmark path and append it to the bookmarks file
    echo "file://$dir" >> $BOOKMARKS_FILE
done < $DIR_FILE
#+END_SRC

* Unused scripts

Note: the following code blocks are not being tangled and not part of my current system.

** aandelen.sh
My shell script which extracts information from a portfolio and calculates percentages and pastes the information to the system clipboards.

#+BEGIN_SRC bash
	#!/bin/sh
	#~/.config/aandelen.sh
	#                       _      _                  _
	#  __ _  __ _ _ __   __| | ___| | ___ _ __    ___| |__
	# / _` |/ _` | '_ \ / _` |/ _ \ |/ _ \ '_ \  / __| '_ \
	#| (_| | (_| | | | | (_| |  __/ |  __/ | | |_\__ \ | | |
	# \__,_|\__,_|_| |_|\__,_|\___|_|\___|_| |_(_)___/_| |_|
	#
	# Automating some routines :-)
	# Opens up a mark down file and places data to clipboard.
	# This clipboard data consists of my current stock portfolio, which is taken
	# from ~/Downloads/Portfolio.csv, which is sorted by stock size, then the
	# percentage is calculated and some other stuff.
	#
	# Open markdown file in the terminal
	alacritty -e vim $HOME/Stack/Documenten/Aandelen/aandelen_log.md &
	# make directory in ram memory of user
	# df -T # to see the ram memory usage
	mkdir $XDG_RUNTIME_DIR/temp &
	# Fetch data from the .csv: two columns, stock name and size and sorth them by
	# size and write to TempSorted
	cat $HOME/Downloads/Portfolio.csv | sed "1,2 d" | cut -d , -f 1,7 | sed 's/"//'| sort -r -t ',' --key=6 > $XDG_RUNTIME_DIR/temp/TempSorted &&
	# Take only the size of stocks and calculate percentage and add this in brackets to a temp file
	cat $XDG_RUNTIME_DIR/temp/TempSorted | cut -d , -f 2 | awk '{a[NR] = $1; sum+= $1 } END {for (i = 1; i <= NR; i++) printf "%s %1.1f %\n", a[i],(100 * a[i])/sum}' > $XDG_RUNTIME_DIR/temp/TempPerc &&
	# Write only the stockname to temp file
	cat $XDG_RUNTIME_DIR/temp/TempSorted | cut -d , -f 1  > $XDG_RUNTIME_DIR/temp/TempName &&
	# Combine TempPerc and TempName
	paste $XDG_RUNTIME_DIR/temp/TempPerc $XDG_RUNTIME_DIR/temp/TempName > $XDG_RUNTIME_DIR/temp/TempMerged &&
	# Add a line for markdown formatting
	echo '================================================================================' > $XDG_RUNTIME_DIR/temp/TempLine1 &&
	# Fetch the date of the portfolio.csv file and write to TempDate
	date +%d%h%y -r $HOME/Downloads/Portfolio.csv >> $XDG_RUNTIME_DIR/temp/TempDate && # find date of .csv file and write to temp file
	# Write text to TempLine2a
	echo ', portfolio:' > $XDG_RUNTIME_DIR/temp/TempLine2a &&
	# Calculate the sum of all stocks and write in TempTotal
	cat $XDG_RUNTIME_DIR/temp/TempPerc | cut -d , -f 1 | awk '{n += $1}; END{print n}' > $XDG_RUNTIME_DIR/temp/TempTotal &&
	# Again some text is written, this time to TempLine2b
	echo 'euro, winst:  euro.' > $XDG_RUNTIME_DIR/temp/TempLine2b &&
	# Text of three temp files are combined in one single line: TempLine2New
	paste $XDG_RUNTIME_DIR/temp/TempDate $XDG_RUNTIME_DIR/temp/TempLine2a $XDG_RUNTIME_DIR/temp/TempTotal $XDG_RUNTIME_DIR/temp/TempLine2b > $XDG_RUNTIME_DIR/temp/TempLine2New &&
	# Text of four temp files are combined to the final temp file: TempNieuw
	cat $XDG_RUNTIME_DIR/temp/TempLine1 $XDG_RUNTIME_DIR/temp/TempLine2New $XDG_RUNTIME_DIR/temp/TempLine1 $XDG_RUNTIME_DIR/temp/TempMerged > $XDG_RUNTIME_DIR/temp/TempNieuw &&
	# Placing the TempNieuw data in the clipboard memory
	cat $XDG_RUNTIME_DIR/temp/TempNieuw | xclip -sel clip &&
	# Remove the created temp files
	rm $XDG_RUNTIME_DIR/temp/Temp*
#+END_SRC

** dwmbackup.sh
#+BEGIN_SRC bash
	#!/bin/bash
	# ~/.config/dwmbackup.sh
	#     _                    _                _                     _
	#  __| |_      ___ __ ___ | |__   __ _  ___| | ___   _ _ __   ___| |__
	# / _` \ \ /\ / / '_ ` _ \| '_ \ / _` |/ __| |/ / | | | '_ \ / __| '_ \
	#| (_| |\ V  V /| | | | | | |_) | (_| | (__|   <| |_| | |_) |\__ \ | | |
	# \__,_| \_/\_/ |_| |_| |_|_.__/ \__,_|\___|_|\_\\__,_| .__(_)___/_| |_|
	#                                                     |_|
	#                                                   Created by Prutserdt
	#
	# This script gives yes/no option to mak a local backup of dwmm.
	# This shell script can be called by the .bashrc alias dwmbackup.
	echo -n "Are you sure you want to make a backup of the current dwm system? (y/n) "
	read answer
	# if echo "$answer" | grep -iq "^y" ;then
	if [ "$answer" != "${answer#[Yy]}" ] ;then
	    rm -r ~/Stack/Dotfiles/dwm/dwm-6.2_stable/* &&
	    cp -r ~/.config/suckless/dwm/* ~/Stack/Dotfiles/dwm/dwm-6.2_stable
	#    rm -r ~/Stack/suckless/dwm/dwm-6.2_stable/* &&
	#    cp -r ~/suckless/dwm/* ~/Stack/suckless/dwm/dwm-6.2_stable
	else
	    echo No
	fi
#+END_SRC

** dwmbar.sh
#+BEGIN_SRC bash
	#!/bin/sh
	#~/.config/dwmbar.sh
	#     _                    _                    _
	#  __| |_      ___ __ ___ | |__   __ _ _ __ ___| |__
	# / _` \ \ /\ / / '_ ` _ \| '_ \ / _` | '__/ __| '_ \
	#| (_| |\ V  V /| | | | | | |_) | (_| | | _\__ \ | | |
	# \__,_| \_/\_/ |_| |_| |_|_.__/ \__,_|_|(_)___/_| |_|
	#                                 Created by Prutserdt
	#
	# Update dwm status bar every minute and give as output
	# updatebar.sh
	while true
	do
	$HOME/.config/updatebar.sh
	  sleep 60
	done
#+END_SRC

** dwmpatch.sh
#+BEGIN_SRC bash
	#!/bin/bash
	# ~/.config/dwmpatch.sh
	#     _                                _       _           _
	#  __| |_      ___ __ ___  _ __   __ _| |_ ___| |__    ___| |__
	# / _` \ \ /\ / / '_ ` _ \| '_ \ / _` | __/ __| '_ \  / __| '_ \
	#| (_| |\ V  V /| | | | | | |_) | (_| | || (__| | | |_\__ \ | | |
	# \__,_| \_/\_/ |_| |_| |_| .__/ \__,_|\__\___|_| |_(_)___/_| |_|
	#                         |_|                Created by Prutserdt
	#
	# This script gives yes/no option to mak a local backup of dwmm.
	#
	# Patch automation. THIS WIL DELETE ALL dwm DIRECTORY FILES!
	# 1: delete files in test directory and restore the stable dwm verstion.
	# 2: write the diff filename to the diff_log
	# 3: Run the patch
	#
	# This shell script can be called by the .bashrc alias dwmbackup.
	echo -n "Are you sure you want to patch the current dwm system? This will
	first: RESTORE TO THE STABLE DWM and after that make clean install on the .diff
	file in the direcotory ~/Stack/Dotfiles/suckless/dwm/patches/test. Yes or no? (y/n) "
	read answer
	# if echo "$answer" | grep -iq "^y" ;then
	if [ "$answer" != "${answer#[Yy]}" ] ;then
	    rm -r ~/.config/suckless/dwm &&
	    mkdir ~/.config/suckless/dwm &&
	    mkdir ~/.config/suckless/dwm/log &&
	    cp -r ~/Stack/Dotfiles/suckless/dwm/dwm-6.2_stable/* ~/.config/suckless/dwm &&
	    cd ~/.config/suckless/dwm &&
	    clear && ls -al &&
	    ls ~/Stack/Dotfiles/suckless/dwm/patches/test/*.diff >> ~/.config/suckless/dwm/log/diff_log &&
	    cp -r ~/.config/suckless/dwm/config.h ~/.config/suckless/dwm/config.def.h &&
	    rm ~/.config/suckless/dwm/config.h &&
	    patch -p1 < ~/Stack/Dotfiles/suckless/dwm/patches/test/*.diff &&
	    make clean install
	#    rm -r ~/suckless/dwm &&
	#    mkdir ~/suckless/dwm &&
	#    mkdir ~/suckless/dwm/log &&
	#    cp -r ~/Stack/suckless/dwm/dwm-6.2_stable/* ~/suckless/dwm &&
	#    cd ~/suckless/dwm &&
	#    clear && ls -al &&
	#    ls ~/Stack/suckless/dwm/patches/test/*.diff >> ~/suckless/dwm/log/diff_log &&
	#    cp -r ~/suckless/dwm/config.h ~/suckless/dwm/config.def.h &&
	#    rm ~/suckless/dwm/config.h &&
	#    patch -p1 < ~/Stack/suckless/dwm/patches/test/*.diff &&
	#    make clean install
	else
	    echo No
	fi
#+END_SRC

** dwmstable.sh
#+BEGIN_SRC bash
	#!/bin/bash
	# ~/.config/dwmstable.sh
	#     _                        _        _     _            _
	#  __| |_      ___ __ ___  ___| |_ __ _| |__ | | ___   ___| |__
	# / _` \ \ /\ / / '_ ` _ \/ __| __/ _` | '_ \| |/ _ \ / __| '_ \
	#| (_| |\ V  V /| | | | | \__ \ || (_| | |_) | |  __/_\__ \ | | |
	# \__,_| \_/\_/ |_| |_| |_|___/\__\__,_|_.__/|_|\___(_)___/_| |_|
	#                                            Created by Prutserdt
	#
	# This script gives yes/no option to mak a local backup of dwmm.
	# This script can be called by the .bashrc alias dwmbackup.
	echo -n "Are you sure you want to restore to the stable version and DELETE
	the current dwm version? (y/n) "
	read answer
	# if echo "$answer" | grep -iq "^y" ;then
	if [ "$answer" != "${answer#[Yy]}" ] ;then
	    rm -r ~/.config/suckless/dwm &&
	    mkdir ~/.config/suckless/dwm &&
	    mkdir ~/.config/suckless/dwm/log &&
	    cp -r ~/Stack/Dotfiles/suckless/dwm/dwm-6.2_stable/* ~/.config/suckless/dwm &&
	    cd ~/.config/suckless/dwm && # does not change directory, also not after
	    #entering 'sleep 5' in front of this. strange
	    clear && ls -al
	else
	    echo No
	fi
#+END_SRC

** dwmvanilla.sh
#+BEGIN_SRC bash
	#!/bin/bash
	# ~/.config/dwmvanilla.sh
	#    _                                    _ _ _             _
	# __| |_      ___ __ _____   ____ _ _ __ (_) | | __ _   ___| |__
	#/ _` \ \ /\ / / '_ ` _ \ \ / / _` | '_ \| | | |/ _` | / __| '_ \
	# (_| |\ V  V /| | | | | \ V / (_| | | | | | | | (_| |_\__ \ | | |
	#\__,_| \_/\_/ |_| |_| |_|\_/ \__,_|_| |_|_|_|_|\__,_(_)___/_| |_|
	#                                             Created by Prutserdt
	#
	# This script gives yes/no option to restore to vanilla dwmm.
	# This script can be called by the .bashrc alias dwmbackup.
	echo -n "Are you sure you want to restore to vanilla dwm and DELETE the current dwm system? (y/n) "
	read answer
	# if echo "$answer" | grep -iq "^y" ;then
	if [ "$answer" != "${answer#[Yy]}" ] ;then
	    rm -r ~/.config/suckless/dwm &&
	    mkdir ~/.config/suckless/dwm &&
	    cp -r ~/Stack/Dotfiles/suckless/dwm/dwm-6.2_20200512_vanilla/* ~/.config/suckless/dwm &&
	    cd ~/.config/suckless/dwm &&
	    clear && ls -al
	#    rm -r ~/suckless/dwm &&
	#    mkdir ~/suckless/dwm &&
	#    cp -r ~/Stack/suckless/dwm/dwm-6.2_20200512_vanilla/* ~/suckless/dwm &&
	#    cd ~/suckless/dwm &&
	#    clear && ls -al
	else
	    echo No
	fi
#+END_SRC

** exitdwm.sh
#+BEGIN_SRC bash
	#!/bin/bash
	# ~/.config/exitdwm.sh
	#           _ _      _                          _
	#  _____  _(_) |_ __| |_      ___ __ ___    ___| |__
	# / _ \ \/ / | __/ _` \ \ /\ / / '_ ` _ \  / __| '_ \
	#|  __/>  <| | || (_| |\ V  V /| | | | | |_\__ \ | | |
	# \___/_/\_\_|\__\__,_| \_/\_/ |_| |_| |_(_)___/_| |_|
	#                                 Created by Prutserdt
	#
	# This script gives yes/no option before exiting dwm.
	# It is set in config.h of dwm.
	echo -n "Do you wish to violently exit DWM now and    kill em all?   (y/n) "
	read answer
	# if echo "$answer" | grep -iq "^y" ;then
	if [ "$answer" != "${answer#[Yy]}" ] ;then
	   killall dwm
	else
	    echo No
	fi
#+END_SRC

** updatebar.sh
#+BEGIN_SRC bash
	#!/bin/sh
	#~/.config/updatebar.sh
	#                 _       _       _                    _
	# _   _ _ __   __| | __ _| |_ ___| |__   __ _ _ __ ___| |__
	#| | | | '_ \ / _` |/ _` | __/ _ \ '_ \ / _` | '__/ __| '_ \
	#| |_| | |_) | (_| | (_| | ||  __/ |_) | (_| | | _\__ \ | | |
	# \__,_| .__/ \__,_|\__,_|\__\___|_.__/ \__,_|_|(_)___/_| |_|
	#      |_|                               Created by Prutserdt
	#
	# Outputs mute icon, master volume, date and time
	# This script is called after booting by another script: ~/.config/dwmbar.sh
	# This script is also called after using volume/mute keys, see dwm config.h
	mute="$(amixer get Master | tail -n1 | sed -r "s/.*\[(.*)].*/\1/")"
	if [ $mute = "off" ]; then
	xsetroot -name " ðŸ”‡`amixer get Master | tail -n1 | sed -r "s/.*\[(.*)%\].*/\1/"`% `date +"%d%h%y %H:%M"`"
	else
	xsetroot -name " ðŸ”‰`amixer get Master | tail -n1 | sed -r "s/.*\[(.*)%\].*/\1/"`% `date +"%d%h%y %H:%M"`"
	fi
#+END_SRC

** wololo.sh
Simple cheat code for 0ad. Does not properly work.

#+BEGIN_SRC bash
	#!/bin/sh
	#~/.config/wololo.sh
	#               _       _            _
	#__      _____ | | ___ | | ___   ___| |__
	#\ \ /\ / / _ \| |/ _ \| |/ _ \ / __| '_ \
	# \ V  V / (_) | | (_) | | (_) |\__ \ | | |
	#  \_/\_/ \___/|_|\___/|_|\___(_)___/_| |_|
	#                      Created by Prutserdt
	#
	# Script to cheat in 0 ad
	sleep 1 && xdotool type wololo && sleep 1 && xdotool key 0xff0d
#+END_SRC

* Tips and tricks

** Fetch all scrips of ~/.config by this code block
The next code block will give the output of all of the ~*.sh~ scripts of the ~~/.config~ as separate code blocks. Very handy to import all of 'em.

#+name: fetch-shell-scripts
#+BEGIN_SRC bash :results raw output
cd $HOME/.config;
for f in *.sh; do
  echo "** $f"
  echo "#+BEGIN_SRC bash " # \ escape voor " character
  paste /dev/null - < "$f" #Geeft de inhoud van de php file
  echo "#+END_SRC"
  echo ""
done
#+END_SRC

** Some notes about the code blocks and tangling.
Shell scripts need to be executable, and during tangling a flag should be added to keep the file executable, ~tangle:mode (identity #o755).~
For example: ~#+BEGIN_SRC python :tangle aandelen.py :padline no :eval no :tangle-mode (identity #o755)~.

To make the tangling process easier I am using the [[https://github.com/yilkalargaw/org-auto-tangle][org-auto-tangle]] package to automate tangling when the file is saved. Therefore in this org file the header contains ~#+auto_tangle: t.
