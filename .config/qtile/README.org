#+TITLE: My configuration of
#+STARTUP: show everything
#+STARTUP: inlineimages
#+auto_tangle: t
#+AUTHOR: Prutserdt

#+CAPTION: Qtile
#+ATTR_HTML: :alt Qtile :title Qtile :align center :width 400px
[[file:Qtile.png]]

* Table of contents :toc:
- [[#my-configuration-of-qtile][My configuration of Qtile]]
- [[#configpy][Config.py]]
  - [[#imports][Imports]]
  - [[#variables][Variables]]
  - [[#custom-functions][Custom functions]]
  - [[#keybindings-qtile-specific][Keybindings: Qtile specific]]
  - [[#keybindings-audio-monitor-brightness-and-print][Keybindings: Audio, monitor brightness and print]]
  - [[#keybindings-applications-and-files-connected-to-these-hotkeys][Keybindings: Applications (and files connected to these hotkeys)]]
  - [[#keybingings-text-files][Keybingings: Text files]]
  - [[#groups][Groups]]
  - [[#layouts][Layouts]]
  - [[#some-hooks][Some hooks]]
- [[#emacs-python-script][Emacs Python script]]
- [[#the-autostartsh-script][The autostart.sh script]]

* My configuration of Qtile
[[http://www.qtile.org/][Qtile]] is a full-featured, hackable tiling window manager written and configured in Python. In this README.org Emacs document my configuration of Qtile is described and it is used as the source to create the Qtile configuration file [[https://github.com/Prutserdt/dotfiles/blob/master/.config/qtile/config.py][config.py]], a small script named [[https://github.com/Prutserdt/dotfiles/blob/master/.config/qtile/open_emacs.py][open_emacs.py]] and the shell script [[https://github.com/Prutserdt/dotfiles/blob/master/.config/qtile/autostart.sh][autostart.sh]].

* Config.py
This is the configuration file of Qtile.
** Imports
A note is added to ~config.py~ which reminds *not* to edit this file directly.
#+BEGIN_SRC python :tangle config.py :results none
# NOTE: This file is generated from ~/.config/qtile/README.org
#       Please only edit that file and org-babel-tangle (Emacs)
#+end_src

My configuration requires some modules to be loaded. These are all default configuration settings of Qtile.
#+BEGIN_SRC python :tangle config.py :results none
import psutil, subprocess, os
from typing import List
from libqtile import bar, layout, widget,hook
from libqtile.config import ( Click, Drag, Group, Key, KeyChord, Match,
                                Screen, ScratchPad, DropDown,)
from libqtile.lazy import lazy
from os.path import expanduser
#from subprocess import check_output # uncomment for battery, Lenovo Thinkpad

#+END_SRC

** Variables
Some variables are declared. The left super key, right super key and right alt key are used for keybindings. Also a variable is used to refer to my open_emacs.py script and home.
#+BEGIN_SRC python :tangle config.py :results none
mL = "mod4"                       # Left super key, dedicated to the windowmanager
mR = "mod3"                       # Right super key, dedicated to open applications
aR = "mod5"                       # Right alt key, dedicated to opening of files
emacs_script = expanduser("~/.config/qtile/open_emacs.py")
home = os.path.expanduser("~")
#+END_SRC

** Custom functions
These functions are used for keybindings and are utilized in the following keybinding section.
#+BEGIN_SRC python :tangle config.py
def threecol(qtile):
    qtile.cmd_to_layout_index(0) #0:monadthreecolumn

def montall(qtile):
    qtile.cmd_to_layout_index(1) #1: monadtall

def monwide(qtile):
    qtile.cmd_to_layout_index(2) #2: monadwide
#+END_SRC

Three functions to change the gap size between windows, in Qtile this is called margins.
#+BEGIN_SRC python :tangle config.py
@lazy.layout.function
def increase_margin(self):
    self.margin += 30
    self.group.layout_all()

@lazy.layout.function
def decrease_margin(self):
    new_margin = self.margin - 5
    if new_margin < 0:
        new_margin = 0
    self.margin = new_margin
    self.group.layout_all()

@lazy.layout.function
def reset_margin(self):
    self.margin = 0
    self.group.layout_all()
#+END_SRC

The status of the battery of a laptop can be monitored by uncommenting the next part.
#+BEGIN_SRC python :tangle config.py

# uncomment for battery, for my Lenovo laptop
# def get_battery_status():
#     battery = check_output(['acpi'])
#     battery = battery.decode("utf-8")
#     battery = battery.strip()
#    return battery
#+END_SRC


** Keybindings: Qtile specific
My left super key bindings are all related to Qtile, for instance moving windows around.
#+BEGIN_SRC python :tangle config.py :results none

keys = [
    Key([mL], "Return", lazy.spawn("alacritty"),        desc="Launch terminal in new window"),
    Key([mL], "space", lazy.layout.swap_main(),         desc="Make main window of selected window"),
    Key([mL], "b", lazy.hide_show_bar(position="top"),  desc="Toggle the bar"),
    Key([mL], "f", lazy.window.toggle_fullscreen(),     desc="Fullscreen the current window"),
    Key([mL], "r", lazy.spawncmd(),                     desc="Prompt commands from taskbar"),
    Key([mL], "t", lazy.window.toggle_floating(),       desc="Toggle floating state"),
    Key([mL], "q", lazy.window.kill(),                  desc="Kill focused window"),
    Key([mL,  "control"], "r", lazy.reload_config(),    desc="Reload the Qtile configuration"),
    Key([mL,  "shift"], "q", lazy.spawn("alacritty -e"+ expanduser("~/.config/exitqtile.sh")), desc="Shutdown Qtile by a shellscript"),

    #Hotkeys to move windows around, resize windows and choose layouts
    Key([mL], "j", lazy.layout.down(),                  desc="Move window focus down"),
    Key([mL], "k", lazy.layout.up(),                    desc="Move window focus up"),
    Key([mL, "shift"], "h", lazy.layout.shuffle_left(), desc="Move window to the left"),
    Key([mL, "shift"], "l", lazy.layout.shuffle_right(),desc="Move window to the right"),
    Key([mL, "shift"], "j", lazy.layout.shuffle_down(), desc="Move window down"),
    Key([mL, "shift"], "k", lazy.layout.shuffle_up(),   desc="Move window up"),
    Key([mL, "control"], "h", lazy.layout.grow(),       desc="Grow the selected window"),
    Key([mL, "control"], "j", lazy.layout.shrink_main(),desc="Shrink the main window"),
    Key([mL, "control"], "k", lazy.layout.grow_main(),  desc="Grow the main window"),
    Key([mL, "control"], "l", lazy.layout.shrink(),     desc="Shrink the selected window"),
    Key([mL], "y", lazy.function(montall),              desc="Layout: MonadTall no margins"),
    Key([mL], "u", lazy.function(threecol),             desc="Layout: Threecolumn  without margins"),
    Key([mL], "i", lazy.function(monwide),              desc="Layout: MonadWide no margins"),
    Key([mL], 'a', increase_margin,                     desc="Increase gaps"),
    Key([mL, "shift"], "a", decrease_margin,            desc="Decrease gaps"),
    Key([mL], "m", reset_margin,                        desc="Reset gaps to zero"),
    #+END_SRC

The next code block example is about keychording, a concept used in Emacs that can select functions by typing separate characters, and no more need to keep modifyer keys pressed. I am not using it for the moment, since it can be a bit confusing and not clear enough when the keychord mode is selected. I keep this here just for future reference.
#+BEGIN_SRC :results none
 KeyChord([mL], "m", [      # testje, keychording werkt!! :-)
     Key([], "u",lazy.spawn("amixer -q set Master 5%+")),
     Key([], "i",lazy.spawn("amixer -q set Master 5%-")),
     ],
     mode="Margins" # als je mode kiest dan moet je eruit met escape....
     ),
#+END_SRC

** Keybindings: Audio, monitor brightness and print
Hotkeys to control the volume, muting, printscreen, OCR from printscreen and change monitor brightness and color.
#+BEGIN_SRC python :tangle config.py :results none
    # Hotkeys for audio and printscreen
    Key([], "XF86AudioRaiseVolume", lazy.spawn('amixer -q set Master 5%+'), lazy.spawn('notify-send -t 6000 "volume increased"')),
    Key([], "XF86AudioLowerVolume", lazy.spawn("amixer -q set Master 5%-"), lazy.spawn('notify-send -t 6000 "volume decreased"')),
    Key([], "XF86AudioMute", lazy.spawn("amixer -q set Master toggle"), lazy.spawn('notify-send -t 6000 "Volume muting toggled"')),
    Key([], "Print", lazy.spawn("xfce4-screenshooter -r -s " + expanduser("~/Downloads")), lazy.spawn('notify-send -t 6000 "Running xfce4-screenshooter, please select area with your mouse to make a screenshot"')),
    Key(["shift"], "Print", lazy.spawn(expanduser("~/.config/screenshot2text.sh"))),
    # The following hotkeys of my Redox keyboard are free to be used..!
    # Key([], "XF86Launch5", lazy.spawn(''), lazy.spawn('notify-send -t 6000 ""')),
    # Key([], "XF86Launch6", lazy.spawn(''), lazy.spawn('notify-send -t 6000 ""')),
    # Key([], "XF86Launch7", lazy.spawn(''), lazy.spawn('notify-send -t 6000 ""')),
    # Key([], "XF86Launch8", lazy.spawn(''), lazy.spawn('notify-send -t 6000 ""')),
    Key([], "XF86Launch9", lazy.spawn(expanduser("~/.config/resetRGB.sh"))),
    Key([], "XF86MonBrightnessUp", lazy.spawn(expanduser("~/.config/incrMonitorBrightness.sh"))),
    Key([], "XF86MonBrightnessDown", lazy.spawn(expanduser("~/.config/decrMonitorBrightness.sh"))),
#+END_SRC

** Keybindings: Applications (and files connected to these hotkeys)
Right super key to open applications. Shift is used to update the application.
#+BEGIN_SRC python :tangle config.py :results none
    # Open applications
    Key([mR], "a",
        lazy.spawn("python " + expanduser("~/.config/aandelen.py")),
        lazy.spawn(f"python3 {emacs_script} {expanduser('~/Stack/Documenten/Aandelen/aandelen_log.org')}"),
        desc="Open in emacs: run het python aandelen script en open het aandelen log"),
    Key([mR], "b", lazy.spawn(expanduser("~/.config/dmenuinternet.sh"))), # browser via dmenu, related to 'urls'
    Key([mR], "d", lazy.spawn(expanduser("~/.config/dmenuapps.sh"))),
    Key([mR, "shift"], "d", lazy.spawn(expanduser("~/.config/dmenuUpdate.sh"))),
    Key([mR], "e", lazy.spawn("emacsclient -c -a 'emacs'")),
    Key([mR], "f", lazy.spawn("firefox")),
    Key([mR], "g", lazy.spawn("gimp")),
    Key([mR], "k", lazy.spawn("keepass")),
    Key([mR], "m", lazy.spawn("mousepad")),
    Key([mR], "s", lazy.spawn("xfce4-screenshooter -s " + expanduser("~~/Downloads"))),
    Key([mR, "shift"], "s", lazy.spawn("signal-desktop --start-in-tray --use-tray-icon")),
    Key([mR], "t", lazy.spawn(expanduser("~/.config/dmenuthunar.sh"))), # related to 'directories'
    Key([mR], "u", lazy.spawn(expanduser("~/.config/dmenuunicode.sh"))), # related to 'unicode'
    Key([mR], "v", lazy.spawn("alacritty -e vim")),
    Key([mR], "w", lazy.spawn(expanduser("~/.config/dmenuwallpaper.sh"))),
#+END_SRC

** Keybingings: Text files
The right alt key is used to open text files in Emacs.
#+BEGIN_SRC python :tangle config.py :results none
    # Open text files in emaca
    Key([aR], "a", lazy.spawn(f"python3 {emacs_script} {expanduser('~/Stack/Documenten/Aandelen/aandelen_log.org')}")),
    Key([aR], "b", lazy.spawn(f"python3 {emacs_script} {expanduser('~/Stack/Command_line/urls')}")), # related to dmenuinternet.sh
    Key([aR], "c", lazy.spawn(f"python3 {emacs_script} {expanduser('~/Stack/Command_line/commands.org')}")),
    Key([aR], "d", lazy.spawn(expanduser("~/.config/dmenuemacs.sh"))),
    Key([aR], "e", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.doom.d/README.org')}")),
    Key([aR], "i", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.config/i3/config')}")),
    Key([aR], "n", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.newsboat/config')}")),
    Key([aR], "p", lazy.spawn(f"python3 {emacs_script} {expanduser('~/Stack/Code/git/PowerStrike_code/README.org')}")),
    Key([aR], "q", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.config/qtile/README.org')}")),
    Key([aR], "r", lazy.spawn(f"python3 {emacs_script} {expanduser('~/README.org')}")), # github readme
    Key([aR], "s", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.config/README.org')}")),  # shell scripts readme
    Key([aR, "shift"], "t", lazy.spawn(f"python3 {emacs_script} {expanduser('~/Stack/Command_line/textfiles')}")),
    Key([aR], "t", lazy.spawn(f"python3 {emacs_script} {expanduser('~/Stack/Command_line/directories')}")),  # related to dmenuthunar.sh
    Key([aR], "u", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.config/unicode')}")),  # related to dmenuunicode.sh
    Key([aR], "v", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.vimrc')}")),
    Key([aR], "w", lazy.spawn(expanduser("~/.config/wololo.sh"))),
    Key([aR], "x", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.xinitrc')}")),
    Key([aR], "z", lazy.spawn(f"python3 {emacs_script} {expanduser('~/.zshrc')}")),
]
#+END_SRC

** Groups
The workspaces are described here, which are called Groups in Qtile. I don't need more then four groups so I limited it to that.
#+BEGIN_SRC python :tangle config.py :results none
groups = [Group(i) for i in "1234"]

for i in groups:
    keys.extend(
        [
            Key(
                [mL],      # mL + letter of group = switch to group
                i.name,
                lazy.group[i.name].toscreen(),
                desc="Switch to group {}".format(i.name),
            ),
            # Move and follow focused window to group
            Key(
                [mL, "shift"],
                i.name,
                lazy.window.togroup(i.name,switch_group=True), #True=follow window
                desc="Move and follow the focused window to group {}".format(i.name),
            ),
            # Exactly the same as above, but don't follow the moved window to group
            Key(
                [mL, "control", "shift"],
                i.name,
                lazy.window.togroup(i.name),
                desc="Move the focused window to group {}".format(i.name),
            ),
        ]
    )

groups.append(
    ScratchPad("scratchpad", [
        DropDown("1", "qalculate-gtk", x=0.0, y=0.0, width=0.2, height=0.3,
                 on_focus_lost_hide=False),
    ])
)

keys.extend([
        Key([], "XF86Calculator", lazy.group["scratchpad"].dropdown_toggle("1"), lazy.spawn('notify-send -t 6000 "Running qalculate-gtk"')),
        #Key([], "XF86Favorites", lazy.group["scratchpad"].dropdown_toggle("1")), # For Thinkpad
])

layout_theme = {"border_width": 2,
                "border_focus":  "#d75f5f",
                "border_normal": "#282C35", #966363
                "min_ratio": 0.05, "max_ratio": 0.9,
                "new_client_position":'bottom',
                }
# A separate theme for floating mode, different color, thicker border width
floating_theme = {"border_width": 3,
                "border_focus": "#98BE65",  #98C379= groen
                "border_normal": "#006553",
                }
#+END_SRC

** Layouts
I mainly use the MonadThreeCol layout, which is similar to DWM's centered master and can switch to tall and wide mode and use gaps or no gaps for these layouts.
Make sure that networkmanager is installed and that nm-applet is part of the autostart.sh, no need to add extras to the top bar.

#+BEGIN_SRC python :tangle config.py :results none
layouts = [
   layout.MonadThreeCol(**layout_theme),
   layout.MonadTall(**layout_theme),
   layout.MonadWide(**layout_theme),
#  layout.DistractionFree(**layout_theme), # toegevoegd 03MAR23
]

widget_defaults = dict(
    font="hack",
    fontsize=12,
    padding=3,
)
extension_defaults = widget_defaults.copy()

screens = [
    Screen(
        top=bar.Bar(
            [
                widget.GroupBox(foreground="#555555"),
                widget.CurrentLayout(foreground="#777777"),
                widget.Prompt(foreground="#777777"),
                widget.WindowName(),
                widget.Chord(
                    chords_colors={
                        "launch": ("#ff0000", "#ffffff"),
                    },
                    name_transform=lambda name: name.upper(),
                ),
                widget.Notify(foreground="#ff966c"),
                widget.Systray(),
                widget.QuickExit(foreground="#888888"),
                # uncomment for battery, Lenovo Thinkpad
                #widget.Battery(
                #    battery=1,
                #    format='{char} {percent:2.0%}',
                #    update_interval=30,
                #),
                widget.Volume(foreground="#d75f5f"),
                widget.Clock(format="%d%b%y %H:%M",foreground="#888888"),
            ],
            24,
            opacity=0.85,
        ),
    ),
]

# Drag floating layouts.
mouse = [
    Drag([mL], "Button1",
        lazy.window.set_position_floating(), start=lazy.window.get_position()
        ),
    Drag([mL], "Button3",
        lazy.window.set_size_floating(), start=lazy.window.get_size()
        ),
    Click([mL], "Button2",
        lazy.window.bring_to_front()
        ),
]

dgroups_key_binder = None
dgroups_app_rules = []  # type: List
follow_mouse_focus = True
bring_front_click = False
cursor_warp = False
floating_layout = layout.Floating(**floating_theme,
    float_rules=[
        # Run utility of `xprop` to see the wm class and name of an X client
        ,*layout.Floating.default_float_rules,
        Match(wm_class="gimp"),      # gimp image editor
        Match(wm_class="keepass2"),  # keepass password editor
    ],
)

auto_fullscreen = False
focus_on_window_activation = "smart"
reconfigure_screens = True

auto_minimize = True # for steam games

#+END_SRC

** Some hooks
A startup script is ran after startup of Qtile and the window swallowing is set here to swallow the terminal window when an application is started in it (which is reopened after closing of the applications).

#+BEGIN_SRC python :tangle config.py

# Startup scripts
@hook.subscribe.startup_once
def start_once():
    home = os.path.expanduser("~")
    subprocess.call([home + "/.config/qtile/autostart.sh"])
    home = os.path.expanduser("~")
#    subprocess.call([expanduser("~/.config/qtile/autostart.sh")])

# swallow window when starting application from terminal
@hook.subscribe.client_new
def _swallow(window):
    pid = window.window.get_net_wm_pid()
    ppid = psutil.Process(pid).ppid()
    cpids = {
        c.window.get_net_wm_pid(): wid for wid, c in window.qtile.windows_map.items()
    }
    for i in range(5):
        if not ppid:
            return
        if ppid in cpids:
            parent = window.qtile.windows_map.get(cpids[ppid])
            parent.minimized = True
            window.parent = parent
            return
        ppid = psutil.Process(ppid).ppid()

@hook.subscribe.client_killed
def _unswallow(window):
    if hasattr(window, 'parent'):
        window.parent.minimized = False

wmname = "LG3D"
#+END_SRC



* Emacs Python script
The next piece of code is written to a separate script, named [[https://github.com/Prutserdt/dotfiles/blob/master/.config/qtile/open_emacs.py][open_emacs.py]], and is used to open emacs files. A note is added to ~open_emacs.py~ which reminds *not* to edit this file directly.
#+BEGIN_SRC python :tangle open_emacs.py :results none
# NOTE: This file is generated from ~/.config/qtile/README.org
#       Please only edit that file and org-babel-tangle (Emacs)
#+end_src

First the required libraries are imported.
#+BEGIN_SRC python :tangle open_emacs.py
#!/usr/bin/env python3
import subprocess
import sys
#+END_SRC

The script is using two funtions, the first one is checking if emacs is already running
#+BEGIN_SRC python :tangle open_emacs.py
def is_emacsclient_running():
    try:
        subprocess.check_output(["pgrep", "-f", "emacsclient -c -a emacs*"])
        return True
    except subprocess.CalledProcessError:
        return False
#+END_SRC

The second function is to open a files with Emacs. If the client is running then is should open the current emacsclient and else open a separate emacsclient.
#+BEGIN_SRC python :tangle open_emacs.py
def open_file_with_emacs(FILENAME):
    if is_emacsclient_running():
        subprocess.run(["emacsclient", "-n", FILENAME])
    else:
        subprocess.run(["emacsclient", "-c", "-a", "emacs", FILENAME])
    # Send a message to Emacs and notify-send what was done
    subprocess.run(["emacsclient", "-e", f'(message "Emacs opened {FILENAME}")'])
    subprocess.run(["notify-send", f"Opening of '{FILENAME}' in Emacs"])
#+END_SRC

The code execution starts here and the code will only run if the filename is a single one (sys.argv !=2).
#+BEGIN_SRC python :tangle open_emacs.py
if __name__ == "__main__":
    if len(sys.argv) != 2:
        sys.exit(1)

    FILENAME = sys.argv[1]
    open_file_with_emacs(FILENAME)
#+END_SRC

* The autostart.sh script
This shell script is called in the config.py script and is starting some keyboard specific stuff.

Again a note is added and this time to ~autostart.sh~ to *not* edit this file directly.

#+BEGIN_SRC sh :tangle autostart.sh :eval no :tangle-mode (identity #o755)
#!/bin/bash
# NOTE: This file is generated from ~/.config/qtile/README.org
#       Please only edit that file and org-babel-tangle (Emacs)
#+END_SRC

The us keyboard map is selected and my Alt/Super/Escape keys are changed. With ~xset~ the keyrepeats are increased. Picom is handling the transparancy and the Emacs daemon is started. nm-applet is the NetworkManager applet. Signal is also opened in the tray with the icon.
#+BEGIN_SRC sh :tangle autostart.sh :eval no :tangle-mode (identity #o755)
setxkbmap us &&
xmodmap $HOME/.config/kbswitch &&
$HOME/.config/notify-log.sh $HOME/.config/notify.log && # writing notification to a logfile
xset r rate 300 80 &
picom -b &
/usr/bin/emacs --daemon &
nm-applet &
#signal-desktop --start-in-tray --use-tray-icon &
#$HOME/.config/stack_startup.sh & # Shell script to search for current Stack AppImage
thunar --daemon &
## Next section is for virtual machines. Uncomment all below
## First a short break
#sleep .2 &&
## Then set the correct size of screen. Make sure screen is correct name and size.
#xrandr --output Virtual-1 --mode 1920x1080 &&
## Set the wallpaper
#feh --bg-scale ~/Stack/Afbeeldingen/Wallpapers/default.jpg & # Set wallpaper
#+end_src
